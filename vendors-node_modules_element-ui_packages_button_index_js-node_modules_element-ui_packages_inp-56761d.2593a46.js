(self["webpackChunkyxtx_lib"] = self["webpackChunkyxtx_lib"] || []).push([["vendors-node_modules_element-ui_packages_button_index_js-node_modules_element-ui_packages_inp-56761d"],{

/***/ "./node_modules/element-ui/packages/button/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/element-ui/packages/button/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/button */ "./node_modules/element-ui/packages/button/src/button.vue");


/* istanbul ignore next */
_src_button__WEBPACK_IMPORTED_MODULE_0__["default"].install = function(Vue) {
  Vue.component(_src_button__WEBPACK_IMPORTED_MODULE_0__["default"].name, _src_button__WEBPACK_IMPORTED_MODULE_0__["default"]);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_button__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/element-ui/packages/input/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/element-ui/packages/input/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/input */ "./node_modules/element-ui/packages/input/src/input.vue");


/* istanbul ignore next */
_src_input__WEBPACK_IMPORTED_MODULE_0__["default"].install = function(Vue) {
  Vue.component(_src_input__WEBPACK_IMPORTED_MODULE_0__["default"].name, _src_input__WEBPACK_IMPORTED_MODULE_0__["default"]);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_input__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/element-ui/packages/input/src/calcTextareaHeight.js":
/*!**************************************************************************!*\
  !*** ./node_modules/element-ui/packages/input/src/calcTextareaHeight.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ calcTextareaHeight)
/* harmony export */ });
let hiddenTextarea;

const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`;

const CONTEXT_STYLE = [
  'letter-spacing',
  'line-height',
  'padding-top',
  'padding-bottom',
  'font-family',
  'font-weight',
  'font-size',
  'text-rendering',
  'text-transform',
  'width',
  'text-indent',
  'padding-left',
  'padding-right',
  'border-width',
  'box-sizing'
];

function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);

  const boxSizing = style.getPropertyValue('box-sizing');

  const paddingSize = (
    parseFloat(style.getPropertyValue('padding-bottom')) +
    parseFloat(style.getPropertyValue('padding-top'))
  );

  const borderSize = (
    parseFloat(style.getPropertyValue('border-bottom-width')) +
    parseFloat(style.getPropertyValue('border-top-width'))
  );

  const contextStyle = CONTEXT_STYLE
    .map(name => `${name}:${style.getPropertyValue(name)}`)
    .join(';');

  return { contextStyle, paddingSize, borderSize, boxSizing };
}

function calcTextareaHeight(
  targetElement,
  minRows = 1,
  maxRows = null
) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  let {
    paddingSize,
    borderSize,
    boxSizing,
    contextStyle
  } = calculateNodeStyling(targetElement);

  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

  let height = hiddenTextarea.scrollHeight;
  const result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  let singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = `${ minHeight }px`;
  }
  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = `${ height }px`;
  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
};


/***/ }),

/***/ "./node_modules/element-ui/src/locale/format.js":
/*!******************************************************!*\
  !*** ./node_modules/element-ui/src/locale/format.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/util */ "./node_modules/element-ui/src/utils/util.js");


const RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(Vue) {

  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */

  function template(string, ...args) {
    if (args.length === 1 && typeof args[0] === 'object') {
      args = args[0];
    }

    if (!args || !args.hasOwnProperty) {
      args = {};
    }

    return string.replace(RE_NARGS, (match, prefix, i, index) => {
      let result;

      if (string[index - 1] === '{' &&
        string[index + match.length] === '}') {
        return i;
      } else {
        result = (0,element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(args, i) ? args[i] : null;
        if (result === null || result === undefined) {
          return '';
        }

        return result;
      }
    });
  }

  return template;
}


/***/ }),

/***/ "./node_modules/element-ui/src/locale/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/element-ui/src/locale/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "i18n": () => (/* binding */ i18n),
/* harmony export */   "t": () => (/* binding */ t),
/* harmony export */   "use": () => (/* binding */ use)
/* harmony export */ });
/* harmony import */ var element_ui_src_locale_lang_zh_CN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/locale/lang/zh-CN */ "./node_modules/element-ui/src/locale/lang/zh-CN.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./format */ "./node_modules/element-ui/src/locale/format.js");





const format = (0,_format__WEBPACK_IMPORTED_MODULE_2__["default"])(vue__WEBPACK_IMPORTED_MODULE_3__["default"]);
let lang = element_ui_src_locale_lang_zh_CN__WEBPACK_IMPORTED_MODULE_0__["default"];
let merged = false;
let i18nHandler = function() {
  const vuei18n = Object.getPrototypeOf(this || vue__WEBPACK_IMPORTED_MODULE_3__["default"]).$t;
  if (typeof vuei18n === 'function' && !!vue__WEBPACK_IMPORTED_MODULE_3__["default"].locale) {
    if (!merged) {
      merged = true;
      vue__WEBPACK_IMPORTED_MODULE_3__["default"].locale(
        vue__WEBPACK_IMPORTED_MODULE_3__["default"].config.lang,
        deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(lang, vue__WEBPACK_IMPORTED_MODULE_3__["default"].locale(vue__WEBPACK_IMPORTED_MODULE_3__["default"].config.lang) || {}, { clone: true })
      );
    }
    return vuei18n.apply(this, arguments);
  }
};

const t = function(path, options) {
  let value = i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;

  const array = path.split('.');
  let current = lang;

  for (let i = 0, j = array.length; i < j; i++) {
    const property = array[i];
    value = current[property];
    if (i === j - 1) return format(value, options);
    if (!value) return '';
    current = value;
  }
  return '';
};

const use = function(l) {
  lang = l || lang;
};

const i18n = function(fn) {
  i18nHandler = fn || i18nHandler;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ use, t, i18n });


/***/ }),

/***/ "./node_modules/element-ui/src/locale/lang/zh-CN.js":
/*!**********************************************************!*\
  !*** ./node_modules/element-ui/src/locale/lang/zh-CN.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择',
      noData: '暂无数据'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    },
    image: {
      error: '加载失败'
    },
    pageHeader: {
      title: '返回'
    },
    popconfirm: {
      confirmButtonText: '确定',
      cancelButtonText: '取消'
    },
    empty: {
      description: '暂无数据'
    }
  }
});


/***/ }),

/***/ "./node_modules/element-ui/src/mixins/emitter.js":
/*!*******************************************************!*\
  !*** ./node_modules/element-ui/src/mixins/emitter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function broadcast(componentName, eventName, params) {
  this.$children.forEach(child => {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }
      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast(componentName, eventName, params) {
      broadcast.call(this, componentName, eventName, params);
    }
  }
});


/***/ }),

/***/ "./node_modules/element-ui/src/mixins/locale.js":
/*!******************************************************!*\
  !*** ./node_modules/element-ui/src/mixins/locale.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var element_ui_src_locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/locale */ "./node_modules/element-ui/src/locale/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    t(...args) {
      return element_ui_src_locale__WEBPACK_IMPORTED_MODULE_0__.t.apply(this, args);
    }
  }
});


/***/ }),

/***/ "./node_modules/element-ui/src/mixins/migrating.js":
/*!*********************************************************!*\
  !*** ./node_modules/element-ui/src/mixins/migrating.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/util */ "./node_modules/element-ui/src/utils/util.js");

/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  mounted() {
    if (false) {}
    if (!this.$vnode) return;
    const { props = {}, events = {} } = this.getMigratingConfig();
    const { data, componentOptions } = this.$vnode;
    const definedProps = data.attrs || {};
    const definedEvents = componentOptions.listeners || {};

    for (let propName in definedProps) {
      propName = (0,element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(propName); // compatible with camel case
      if (props[propName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Attribute]: ${props[propName]}`);
      }
    }

    for (let eventName in definedEvents) {
      eventName = (0,element_ui_src_utils_util__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(eventName); // compatible with camel case
      if (events[eventName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Event]: ${events[eventName]}`);
      }
    }
  },
  methods: {
    getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }
  }
});


/***/ }),

/***/ "./node_modules/element-ui/src/utils/clickoutside.js":
/*!***********************************************************!*\
  !*** ./node_modules/element-ui/src/utils/clickoutside.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/dom */ "./node_modules/element-ui/src/utils/dom.js");



const nodeList = [];
const ctx = '@@clickoutsideContext';

let startClick;
let seed = 0;

!vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer && (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.on)(document, 'mousedown', e => (startClick = e));

!vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer && (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.on)(document, 'mouseup', e => {
  nodeList.forEach(node => node[ctx].documentHandler(e, startClick));
});

function createDocumentHandler(el, binding, vnode) {
  return function(mouseup = {}, mousedown = {}) {
    if (!vnode ||
      !vnode.context ||
      !mouseup.target ||
      !mousedown.target ||
      el.contains(mouseup.target) ||
      el.contains(mousedown.target) ||
      el === mouseup.target ||
      (vnode.context.popperElm &&
      (vnode.context.popperElm.contains(mouseup.target) ||
      vnode.context.popperElm.contains(mousedown.target)))) return;

    if (binding.expression &&
      el[ctx].methodName &&
      vnode.context[el[ctx].methodName]) {
      vnode.context[el[ctx].methodName]();
    } else {
      el[ctx].bindingFn && el[ctx].bindingFn();
    }
  };
}

/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  bind(el, binding, vnode) {
    nodeList.push(el);
    const id = seed++;
    el[ctx] = {
      id,
      documentHandler: createDocumentHandler(el, binding, vnode),
      methodName: binding.expression,
      bindingFn: binding.value
    };
  },

  update(el, binding, vnode) {
    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = binding.value;
  },

  unbind(el) {
    let len = nodeList.length;

    for (let i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }
    delete el[ctx];
  }
});


/***/ }),

/***/ "./node_modules/element-ui/src/utils/date.js":
/*!***************************************************!*\
  !*** ./node_modules/element-ui/src/utils/date.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd
(function (main) {
  'use strict';

  /**
   * Parse or format dates
   * @class fecha
   */
  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = '\\d\\d?';
  var threeDigits = '\\d{3}';
  var fourDigits = '\\d{4}';
  var word = '[^\\s]+';
  var literal = /\[([^]*?)\]/gm;
  var noop = function () {
  };

  function regexEscape(str) {
    return str.replace( /[|\\{()[^$+*?.-]/g, '\\$&');
  }

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function(dateObj) {
      return dateObj.getDay();
    },
    DD: function(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return dateObj.getDate();
    },
    dd: function(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    yyyy: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return dateObj.getHours();
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [twoDigits + word, function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date(), cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: ['\\d', function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: ['\\d{2}', function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: ['[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z', function (d, v) {
      var parts = (v + '').match(/([+-]|\d\d)/gi), minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;


  // Some common format strings
  fecha.masks = {
    default: 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    var literals = [];

    // Make literals inactive by replacing them with ??
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return '@@@';
    });
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/@@@/g, function() {
      return literals.shift();
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return null;
    }

    var dateInfo = {};
    var parseInfo = [];
    var literals = [];
    format = format.replace(literal, function($0, $1) {
      literals.push($1);
      return '@@@';
    });
    var newFormat = regexEscape(format).replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        parseInfo.push(info[1]);
        return '(' + info[0] + ')';
      }

      return $0;
    });
    newFormat = newFormat.replace(/@@@/g, function() {
      return literals.shift();
    });
    var matches = dateStr.match(new RegExp(newFormat, 'i'));
    if (!matches) {
      return null;
    }

    for (var i = 1; i < matches.length; i++) {
      parseInfo[i - 1](dateInfo, matches[i], i18n);
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if ( true && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return fecha;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);


/***/ }),

/***/ "./node_modules/element-ui/src/utils/dom.js":
/*!**************************************************!*\
  !*** ./node_modules/element-ui/src/utils/dom.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "getScrollContainer": () => (/* binding */ getScrollContainer),
/* harmony export */   "getStyle": () => (/* binding */ getStyle),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "isInContainer": () => (/* binding */ isInContainer),
/* harmony export */   "isScroll": () => (/* binding */ isScroll),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "once": () => (/* binding */ once),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "setStyle": () => (/* binding */ setStyle)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* istanbul ignore next */



const isServer = vue__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.$isServer;
const SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
const MOZ_HACK_REGEXP = /^moz([A-Z])/;
const ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
const trim = function(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
const camelCase = function(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
const on = (function() {
  if (!isServer && document.addEventListener) {
    return function(element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function(element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
})();

/* istanbul ignore next */
const off = (function() {
  if (!isServer && document.removeEventListener) {
    return function(element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function(element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
})();

/* istanbul ignore next */
const once = function(el, event, fn) {
  var listener = function() {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
};

/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }
  if (!el.classList) {
    el.setAttribute('class', curClass);
  }
};

/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }
  if (!el.classList) {
    el.setAttribute('class', trim(curClass));
  }
};

/* istanbul ignore next */
const getStyle = ieVersion < 9 ? function(element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return (element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null);
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function(element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;

  if (typeof styleName === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
};

const isScroll = (el, vertical) => {
  if (isServer) return;

  const determinedDirection = vertical !== null && vertical !== undefined;
  const overflow = determinedDirection
    ? vertical
      ? getStyle(el, 'overflow-y')
      : getStyle(el, 'overflow-x')
    : getStyle(el, 'overflow');

  return overflow.match(/(scroll|auto|overlay)/);
};

const getScrollContainer = (el, vertical) => {
  if (isServer) return;

  let parent = el;
  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }
    if (isScroll(parent, vertical)) {
      return parent;
    }
    parent = parent.parentNode;
  }

  return parent;
};

const isInContainer = (el, container) => {
  if (isServer || !el || !container) return false;

  const elRect = el.getBoundingClientRect();
  let containerRect;

  if ([window, document, document.documentElement, null, undefined].includes(container)) {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  } else {
    containerRect = container.getBoundingClientRect();
  }

  return elRect.top < containerRect.bottom &&
    elRect.bottom > containerRect.top &&
    elRect.right > containerRect.left &&
    elRect.left < containerRect.right;
};


/***/ }),

/***/ "./node_modules/element-ui/src/utils/merge.js":
/*!****************************************************!*\
  !*** ./node_modules/element-ui/src/utils/merge.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(target) {
  for (let i = 1, j = arguments.length; i < j; i++) {
    let source = arguments[i] || {};
    for (let prop in source) {
      if (source.hasOwnProperty(prop)) {
        let value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
};


/***/ }),

/***/ "./node_modules/element-ui/src/utils/popper.js":
/*!*****************************************************!*\
  !*** ./node_modules/element-ui/src/utils/popper.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//
// Cross module loader
// Supported: Node, AMD, Browser globals
//
;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {

    'use strict';

    var root = window;

    // default options
    var DEFAULTS = {
        // placement of the popper
        placement: 'bottom',

        gpuAcceleration: true,

        // shift popper from its origin by the given amount of pixels (can be negative)
        offset: 0,

        // the element which will act as boundary of the popper
        boundariesElement: 'viewport',

        // amount of pixel used to define a minimum distance between the boundaries and the popper
        boundariesPadding: 5,

        // popper will try to prevent overflow following this order,
        // by default, then, it could overflow on the left and on top of the boundariesElement
        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],

        // the behavior used by flip to change the placement of the popper
        flipBehavior: 'flip',

        arrowElement: '[x-arrow]',

        arrowOffset: 0,

        // list of functions used to modify the offsets before they are applied to the popper
        modifiers: [ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],

        modifiersIgnored: [],

        forceAbsolute: false
    };

    /**
     * Create a new Popper.js instance
     * @constructor Popper
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement|Object} popper
     *      The HTML element used as popper, or a configuration used to generate the popper.
     * @param {String} [popper.tagName='div'] The tag name of the generated popper.
     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
     * @param {Object} options
     * @param {String} [options.placement=bottom]
     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
     *      left(-start, -end)`
     *
     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
     *      reference element.
     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
     *
     * @param {Boolean} [options.gpuAcceleration=true]
     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
     *      browser to use the GPU to accelerate the rendering.
     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
     *
     * @param {Number} [options.offset=0]
     *      Amount of pixels the popper will be shifted (can be negative).
     *
     * @param {String|Element} [options.boundariesElement='viewport']
     *      The element which will define the boundaries of the popper position, the popper will never be placed outside
     *      of the defined boundaries (except if `keepTogether` is enabled)
     *
     * @param {Number} [options.boundariesPadding=5]
     *      Additional padding for the boundaries
     *
     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
     *      this means that the last ones will never overflow
     *
     * @param {String|Array} [options.flipBehavior='flip']
     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
     *      its axis (`right - left`, `top - bottom`).
     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
     *
     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
     *      List of functions used to modify the data before they are applied to the popper, add your custom functions
     *      to this array to edit the offsets and placement.
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Array} [options.modifiersIgnored=[]]
     *      Put here any built-in modifier name you want to exclude from the modifiers list
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Boolean} [options.removeOnDestroy=false]
     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
     */
    function Popper(reference, popper, options) {
        this._reference = reference.jquery ? reference[0] : reference;
        this.state = {};

        // if the popper variable is a configuration object, parse it to generate an HTMLElement
        // generate a default popper if is not defined
        var isNotDefined = typeof popper === 'undefined' || popper === null;
        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
        if (isNotDefined || isConfig) {
            this._popper = this.parse(isConfig ? popper : {});
        }
        // otherwise, use the given HTMLElement as popper
        else {
            this._popper = popper.jquery ? popper[0] : popper;
        }

        // with {} we create a new object with the options inside it
        this._options = Object.assign({}, DEFAULTS, options);

        // refactoring modifiers' list
        this._options.modifiers = this._options.modifiers.map(function(modifier){
            // remove ignored modifiers
            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

            // set the x-placement attribute before everything else because it could be used to add margins to the popper
            // margins needs to be calculated to get the correct popper offsets
            if (modifier === 'applyStyle') {
                this._popper.setAttribute('x-placement', this._options.placement);
            }

            // return predefined modifier identified by string or keep the custom one
            return this.modifiers[modifier] || modifier;
        }.bind(this));

        // make sure to apply the popper position before any computation
        this.state.position = this._getPosition(this._popper, this._reference);
        setStyle(this._popper, { position: this.state.position, top: 0 });

        // fire the first update to position the popper in the right place
        this.update();

        // setup event listeners, they will take care of update the position in specific situations
        this._setupEventListeners();
        return this;
    }


    //
    // Methods
    //
    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    Popper.prototype.destroy = function() {
        this._popper.removeAttribute('x-placement');
        this._popper.style.left = '';
        this._popper.style.position = '';
        this._popper.style.top = '';
        this._popper.style[getSupportedPropertyName('transform')] = '';
        this._removeEventListeners();

        // remove the popper if user explicity asked for the deletion on destroy
        if (this._options.removeOnDestroy) {
            this._popper.remove();
        }
        return this;
    };

    /**
     * Updates the position of the popper, computing the new offsets and applying the new style
     * @method
     * @memberof Popper
     */
    Popper.prototype.update = function() {
        var data = { instance: this, styles: {} };

        // store placement inside the data object, modifiers will be able to edit `placement` if needed
        // and refer to _originalPlacement to know the original value
        data.placement = this._options.placement;
        data._originalPlacement = this._options.placement;

        // compute the popper and reference offsets and put them inside data.offsets
        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

        // get boundaries
        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);

        data = this.runModifiers(data, this._options.modifiers);

        if (typeof this.state.updateCallback === 'function') {
            this.state.updateCallback(data);
        }
    };

    /**
     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onCreate = function(callback) {
        // the createCallbacks return as first argument the popper instance
        callback(this);
        return this;
    };

    /**
     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
     * used to style popper and its arrow.
     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onUpdate = function(callback) {
        this.state.updateCallback = callback;
        return this;
    };

    /**
     * Helper used to generate poppers from a configuration file
     * @method
     * @memberof Popper
     * @param config {Object} configuration
     * @returns {HTMLElement} popper
     */
    Popper.prototype.parse = function(config) {
        var defaultConfig = {
            tagName: 'div',
            classNames: [ 'popper' ],
            attributes: [],
            parent: root.document.body,
            content: '',
            contentType: 'text',
            arrowTagName: 'div',
            arrowClassNames: [ 'popper__arrow' ],
            arrowAttributes: [ 'x-arrow']
        };
        config = Object.assign({}, defaultConfig, config);

        var d = root.document;

        var popper = d.createElement(config.tagName);
        addClassNames(popper, config.classNames);
        addAttributes(popper, config.attributes);
        if (config.contentType === 'node') {
            popper.appendChild(config.content.jquery ? config.content[0] : config.content);
        }else if (config.contentType === 'html') {
            popper.innerHTML = config.content;
        } else {
            popper.textContent = config.content;
        }

        if (config.arrowTagName) {
            var arrow = d.createElement(config.arrowTagName);
            addClassNames(arrow, config.arrowClassNames);
            addAttributes(arrow, config.arrowAttributes);
            popper.appendChild(arrow);
        }

        var parent = config.parent.jquery ? config.parent[0] : config.parent;

        // if the given parent is a string, use it to match an element
        // if more than one element is matched, the first one will be used as parent
        // if no elements are matched, the script will throw an error
        if (typeof parent === 'string') {
            parent = d.querySelectorAll(config.parent);
            if (parent.length > 1) {
                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
            }
            if (parent.length === 0) {
                throw 'ERROR: the given `parent` doesn\'t exists!';
            }
            parent = parent[0];
        }
        // if the given parent is a DOM nodes list or an array of nodes with more than one element,
        // the first one will be used as parent
        if (parent.length > 1 && parent instanceof Element === false) {
            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
            parent = parent[0];
        }

        // append the generated popper to its parent
        parent.appendChild(popper);

        return popper;

        /**
         * Adds class names to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} classes
         */
        function addClassNames(element, classNames) {
            classNames.forEach(function(className) {
                element.classList.add(className);
            });
        }

        /**
         * Adds attributes to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} attributes
         * @example
         * addAttributes(element, [ 'data-info:foobar' ]);
         */
        function addAttributes(element, attributes) {
            attributes.forEach(function(attribute) {
                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
            });
        }

    };

    /**
     * Helper used to get the position which will be applied to the popper
     * @method
     * @memberof Popper
     * @param config {HTMLElement} popper element
     * @param reference {HTMLElement} reference element
     * @returns {String} position
     */
    Popper.prototype._getPosition = function(popper, reference) {
        var container = getOffsetParent(reference);

        if (this._options.forceAbsolute) {
            return 'absolute';
        }

        // Decide if the popper will be fixed
        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
        var isParentFixed = isFixed(reference, container);
        return isParentFixed ? 'fixed' : 'absolute';
    };

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper
     * @access private
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    Popper.prototype._getOffsets = function(popper, reference, placement) {
        placement = placement.split('-')[0];
        var popperOffsets = {};

        popperOffsets.position = this.state.position;
        var isParentFixed = popperOffsets.position === 'fixed';

        //
        // Get reference element position
        //
        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

        //
        // Get popper sizes
        //
        var popperRect = getOuterSizes(popper);

        //
        // Compute offsets of popper
        //

        // depending by the popper placement we have to compute its offsets slightly differently
        if (['right', 'left'].indexOf(placement) !== -1) {
            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
            if (placement === 'left') {
                popperOffsets.left = referenceOffsets.left - popperRect.width;
            } else {
                popperOffsets.left = referenceOffsets.right;
            }
        } else {
            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
            if (placement === 'top') {
                popperOffsets.top = referenceOffsets.top - popperRect.height;
            } else {
                popperOffsets.top = referenceOffsets.bottom;
            }
        }

        // Add width and height to our offsets object
        popperOffsets.width   = popperRect.width;
        popperOffsets.height  = popperRect.height;

        return {
            popper: popperOffsets,
            reference: referenceOffsets
        };
    };


    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._setupEventListeners = function() {
        // NOTE: 1 DOM access here
        this.state.updateBound = this.update.bind(this);
        root.addEventListener('resize', this.state.updateBound);
        // if the boundariesElement is window we don't need to listen for the scroll event
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.addEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = target;
        }
    };

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._removeEventListeners = function() {
        // NOTE: 1 DOM access here
        root.removeEventListener('resize', this.state.updateBound);
        if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
            this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = null;
        }
        this.state.updateBound = null;
    };

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper
     * @access private
     * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
     * @param {Number} padding - Boundaries padding
     * @param {Element} boundariesElement - Element used to define the boundaries
     * @returns {Object} Coordinates of the boundaries
     */
    Popper.prototype._getBoundaries = function(data, padding, boundariesElement) {
        // NOTE: 1 DOM access here
        var boundaries = {};
        var width, height;
        if (boundariesElement === 'window') {
            var body = root.document.body,
                html = root.document.documentElement;

            height = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
            width = Math.max( body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth );

            boundaries = {
                top: 0,
                right: width,
                bottom: height,
                left: 0
            };
        } else if (boundariesElement === 'viewport') {
            var offsetParent = getOffsetParent(this._popper);
            var scrollParent = getScrollParent(this._popper);
            var offsetParentRect = getOffsetRect(offsetParent);

            // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
            var getScrollTopValue = function (element) {
                return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
            }
            var getScrollLeftValue = function (element) {
                return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
            }

            // if the popper is fixed we don't have to substract scrolling from the boundaries
            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);

            boundaries = {
                top: 0 - (offsetParentRect.top - scrollTop),
                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
                left: 0 - (offsetParentRect.left - scrollLeft)
            };
        } else {
            if (getOffsetParent(this._popper) === boundariesElement) {
                boundaries = {
                    top: 0,
                    left: 0,
                    right: boundariesElement.clientWidth,
                    bottom: boundariesElement.clientHeight
                };
            } else {
                boundaries = getOffsetRect(boundariesElement);
            }
        }
        boundaries.left += padding;
        boundaries.right -= padding;
        boundaries.top = boundaries.top + padding;
        boundaries.bottom = boundaries.bottom - padding;
        return boundaries;
    };


    /**
     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
     * @method
     * @memberof Popper
     * @access public
     * @param {Object} data
     * @param {Array} modifiers
     * @param {Function} ends
     */
    Popper.prototype.runModifiers = function(data, modifiers, ends) {
        var modifiersToRun = modifiers.slice();
        if (ends !== undefined) {
            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
        }

        modifiersToRun.forEach(function(modifier) {
            if (isFunction(modifier)) {
                data = modifier.call(this, data);
            }
        }.bind(this));

        return data;
    };

    /**
     * Helper used to know if the given modifier depends from another one.
     * @method
     * @memberof Popper
     * @param {String} requesting - name of requesting modifier
     * @param {String} requested - name of requested modifier
     * @returns {Boolean}
     */
    Popper.prototype.isModifierRequired = function(requesting, requested) {
        var index = getArrayKeyIndex(this._options.modifiers, requesting);
        return !!this._options.modifiers.slice(0, index).filter(function(modifier) {
            return modifier === requested;
        }).length;
    };

    //
    // Modifiers
    //

    /**
     * Modifiers list
     * @namespace Popper.modifiers
     * @memberof Popper
     * @type {Object}
     */
    Popper.prototype.modifiers = {};

    /**
     * Apply the computed styles to the popper element
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The same data object
     */
    Popper.prototype.modifiers.applyStyle = function(data) {
        // apply the final offsets to the popper
        // NOTE: 1 DOM access here
        var styles = {
            position: data.offsets.popper.position
        };

        // round top and left to avoid blurry text
        var left = Math.round(data.offsets.popper.left);
        var top = Math.round(data.offsets.popper.top);

        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
        // we automatically use the supported prefixed version if needed
        var prefixedProperty;
        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
            styles.top = 0;
            styles.left = 0;
        }
        // othwerise, we use the standard `left` and `top` properties
        else {
            styles.left =left;
            styles.top = top;
        }

        // any property present in `data.styles` will be applied to the popper,
        // in this way we can make the 3rd party modifiers add custom styles to it
        // Be aware, modifiers could override the properties defined in the previous
        // lines of this modifier!
        Object.assign(styles, data.styles);

        setStyle(this._popper, styles);

        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
        // NOTE: 1 DOM access here
        this._popper.setAttribute('x-placement', data.placement);

        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
            setStyle(data.arrowElement, data.offsets.arrow);
        }

        return data;
    };

    /**
     * Modifier used to shift the popper on the start or end of its reference element side
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.shift = function(data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var shiftVariation = placement.split('-')[1];

        // if shift shiftVariation is specified, run the modifier
        if (shiftVariation) {
            var reference = data.offsets.reference;
            var popper = getPopperClientRect(data.offsets.popper);

            var shiftOffsets = {
                y: {
                    start:  { top: reference.top },
                    end:    { top: reference.top + reference.height - popper.height }
                },
                x: {
                    start:  { left: reference.left },
                    end:    { left: reference.left + reference.width - popper.width }
                }
            };

            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';

            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
        }

        return data;
    };


    /**
     * Modifier used to make sure the popper does not overflows from it's boundaries
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.preventOverflow = function(data) {
        var order = this._options.preventOverflowOrder;
        var popper = getPopperClientRect(data.offsets.popper);

        var check = {
            left: function() {
                var left = popper.left;
                if (popper.left < data.boundaries.left) {
                    left = Math.max(popper.left, data.boundaries.left);
                }
                return { left: left };
            },
            right: function() {
                var left = popper.left;
                if (popper.right > data.boundaries.right) {
                    left = Math.min(popper.left, data.boundaries.right - popper.width);
                }
                return { left: left };
            },
            top: function() {
                var top = popper.top;
                if (popper.top < data.boundaries.top) {
                    top = Math.max(popper.top, data.boundaries.top);
                }
                return { top: top };
            },
            bottom: function() {
                var top = popper.top;
                if (popper.bottom > data.boundaries.bottom) {
                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);
                }
                return { top: top };
            }
        };

        order.forEach(function(direction) {
            data.offsets.popper = Object.assign(popper, check[direction]());
        });

        return data;
    };

    /**
     * Modifier used to make sure the popper is always near its reference
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.keepTogether = function(data) {
        var popper  = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var f = Math.floor;

        if (popper.right < f(reference.left)) {
            data.offsets.popper.left = f(reference.left) - popper.width;
        }
        if (popper.left > f(reference.right)) {
            data.offsets.popper.left = f(reference.right);
        }
        if (popper.bottom < f(reference.top)) {
            data.offsets.popper.top = f(reference.top) - popper.height;
        }
        if (popper.top > f(reference.bottom)) {
            data.offsets.popper.top = f(reference.bottom);
        }

        return data;
    };

    /**
     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
     * Requires the `preventOverflow` modifier before it in order to work.
     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.flip = function(data) {
        // check if preventOverflow is in the list of modifiers before the flip modifier.
        // otherwise flip would not work as expected.
        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
            return data;
        }

        if (data.flipped && data.placement === data._originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
        }

        var placement = data.placement.split('-')[0];
        var placementOpposite = getOppositePlacement(placement);
        var variation = data.placement.split('-')[1] || '';

        var flipOrder = [];
        if(this._options.flipBehavior === 'flip') {
            flipOrder = [
                placement,
                placementOpposite
            ];
        } else {
            flipOrder = this._options.flipBehavior;
        }

        flipOrder.forEach(function(step, index) {
            if (placement !== step || flipOrder.length === index + 1) {
                return;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            var popperOffsets = getPopperClientRect(data.offsets.popper);

            // this boolean is used to distinguish right and bottom from top and left
            // they need different computations to get flipped
            var a = ['right', 'bottom'].indexOf(placement) !== -1;

            // using Math.floor because the reference offsets may contain decimals we are not going to consider here
            if (
                a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) ||
                !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])
            ) {
                // we'll use this boolean to detect any flip loop
                data.flipped = true;
                data.placement = flipOrder[index + 1];
                if (variation) {
                    data.placement += '-' + variation;
                }
                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;

                data = this.runModifiers(data, this._options.modifiers, this._flip);
            }
        }.bind(this));
        return data;
    };

    /**
     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
     * The offsets will shift the popper on the side of its reference element.
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.offset = function(data) {
        var offset = this._options.offset;
        var popper  = data.offsets.popper;

        if (data.placement.indexOf('left') !== -1) {
            popper.top -= offset;
        }
        else if (data.placement.indexOf('right') !== -1) {
            popper.top += offset;
        }
        else if (data.placement.indexOf('top') !== -1) {
            popper.left -= offset;
        }
        else if (data.placement.indexOf('bottom') !== -1) {
            popper.left += offset;
        }
        return data;
    };

    /**
     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.arrow = function(data) {
        var arrow  = this._options.arrowElement;
        var arrowOffset = this._options.arrowOffset;

        // if the arrowElement is a string, suppose it's a CSS selector
        if (typeof arrow === 'string') {
            arrow = this._popper.querySelector(arrow);
        }

        // if arrow element is not found, don't run the modifier
        if (!arrow) {
            return data;
        }

        // the arrow element must be child of its popper
        if (!this._popper.contains(arrow)) {
            console.warn('WARNING: `arrowElement` must be child of its popper element!');
            return data;
        }

        // arrow depends on keepTogether in order to work
        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
            return data;
        }

        var arrowStyle  = {};
        var placement   = data.placement.split('-')[0];
        var popper      = getPopperClientRect(data.offsets.popper);
        var reference   = data.offsets.reference;
        var isVertical  = ['left', 'right'].indexOf(placement) !== -1;

        var len         = isVertical ? 'height' : 'width';
        var side        = isVertical ? 'top' : 'left';
        var translate   = isVertical ? 'translateY' : 'translateX';
        var altSide     = isVertical ? 'left' : 'top';
        var opSide      = isVertical ? 'bottom' : 'right';
        var arrowSize   = getOuterSizes(arrow)[len];

        //
        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
        //

        // top/left side
        if (reference[opSide] - arrowSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
        }
        // bottom/right side
        if (reference[side] + arrowSize > popper[opSide]) {
            data.offsets.popper[side] += (reference[side] + arrowSize) - popper[opSide];
        }

        // compute center of the popper
        var center = reference[side] + (arrowOffset || (reference[len] / 2) - (arrowSize / 2));

        var sideValue = center - popper[side];

        // prevent arrow from being placed not contiguously to its popper
        sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
        arrowStyle[side] = sideValue;
        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

        data.offsets.arrow = arrowStyle;
        data.arrowElement = arrow;

        return data;
    };


    //
    // Helpers
    //

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
        // NOTE: 1 DOM access here
        var _display = element.style.display, _visibility = element.style.visibility;
        element.style.display = 'block'; element.style.visibility = 'hidden';
        var calcWidthToForceRepaint = element.offsetWidth;

        // original method
        var styles = root.getComputedStyle(element);
        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };

        // reset element styles
        element.style.display = _display; element.style.visibility = _visibility;
        return result;
    }

    /**
     * Get the opposite placement of the given one/
     * @function
     * @ignore
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
        var hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
        return placement.replace(/left|right|bottom|top/g, function(matched){
            return hash[matched];
        });
    }

    /**
     * Given the popper offsets, generate an output similar to getBoundingClientRect
     * @function
     * @ignore
     * @argument {Object} popperOffsets
     * @returns {Object} ClientRect like output
     */
    function getPopperClientRect(popperOffsets) {
        var offsets = Object.assign({}, popperOffsets);
        offsets.right = offsets.left + offsets.width;
        offsets.bottom = offsets.top + offsets.height;
        return offsets;
    }

    /**
     * Given an array and the key to find, returns its index
     * @function
     * @ignore
     * @argument {Array} arr
     * @argument keyToFind
     * @returns index or null
     */
    function getArrayKeyIndex(arr, keyToFind) {
        var i = 0, key;
        for (key in arr) {
            if (arr[key] === keyToFind) {
                return i;
            }
            i++;
        }
        return null;
    }

    /**
     * Get CSS computed property of the given element
     * @function
     * @ignore
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
        // NOTE: 1 DOM access here
        var css = root.getComputedStyle(element, null);
        return css[property];
    }

    /**
     * Returns the offset parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
        // NOTE: 1 DOM access here
        var offsetParent = element.offsetParent;
        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
    }

    /**
     * Returns the scrolling parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getScrollParent(element) {
        var parent = element.parentNode;

        if (!parent) {
            return element;
        }

        if (parent === root.document) {
            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
            // greater than 0 and return the proper element
            if (root.document.body.scrollTop || root.document.body.scrollLeft) {
                return root.document.body;
            } else {
                return root.document.documentElement;
            }
        }

        // Firefox want us to check `-x` and `-y` variations as well
        if (
            ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 ||
            ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 ||
            ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1
        ) {
            // If the detected scrollParent is body, we perform an additional check on its parentNode
            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
            // fixes issue #65
            return parent;
        }
        return getScrollParent(element.parentNode);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @function
     * @ignore
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
        if (element === root.document.body) {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return element.parentNode ? isFixed(element.parentNode) : element;
    }

    /**
     * Set the style to the given popper
     * @function
     * @ignore
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
     */
    function setStyle(element, styles) {
        function is_numeric(n) {
            return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));
        }
        Object.keys(styles).forEach(function(prop) {
            var unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
                unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
        });
    }

    /**
     * Check if the given variable is a function
     * @function
     * @ignore
     * @argument {*} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @function
     * @ignore
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
        var elementRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop
        };

        elementRect.right = elementRect.left + elementRect.width;
        elementRect.bottom = elementRect.top + elementRect.height;

        // position
        return elementRect;
    }

    /**
     * Get bounding client rect of given element
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();

        // whether the IE version is lower than 11
        var isIE = navigator.userAgent.indexOf("MSIE") != -1;

        // fix ie document bounding top always 0 bug
        var rectTop = isIE && element.tagName === 'HTML'
            ? -element.scrollTop
            : rect.top;

        return {
            left: rect.left,
            top: rectTop,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.right - rect.left,
            height: rect.bottom - rectTop
        };
    }

    /**
     * Given an element and one of its parents, return the offset
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @param {HTMLElement} parent
     * @return {Object} rect
     */
    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
        var elementRect = getBoundingClientRect(element);
        var parentRect = getBoundingClientRect(parent);

        if (fixed) {
            var scrollParent = getScrollParent(parent);
            parentRect.top += scrollParent.scrollTop;
            parentRect.bottom += scrollParent.scrollTop;
            parentRect.left += scrollParent.scrollLeft;
            parentRect.right += scrollParent.scrollLeft;
        }

        var rect = {
            top: elementRect.top - parentRect.top ,
            left: elementRect.left - parentRect.left ,
            bottom: (elementRect.top - parentRect.top) + elementRect.height,
            right: (elementRect.left - parentRect.left) + elementRect.width,
            width: elementRect.width,
            height: elementRect.height
        };
        return rect;
    }

    /**
     * Get the prefixed supported property name
     * @function
     * @ignore
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase)
     */
    function getSupportedPropertyName(property) {
        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

        for (var i = 0; i < prefixes.length; i++) {
            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
            if (typeof root.document.body.style[toCheck] !== 'undefined') {
                return toCheck;
            }
        }
        return null;
    }

    /**
     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
     * objects to a target object. It will return the target object.
     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @function
     * @ignore
     */
    if (!Object.assign) {
        Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert first argument to object');
                }

                var to = Object(target);
                for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }
                    nextSource = Object(nextSource);

                    var keysArray = Object.keys(nextSource);
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
                return to;
            }
        });
    }

    return Popper;
}));


/***/ }),

/***/ "./node_modules/element-ui/src/utils/popup/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/element-ui/src/utils/popup/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PopupManager": () => (/* reexport safe */ element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var element_ui_src_utils_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/merge */ "./node_modules/element-ui/src/utils/merge.js");
/* harmony import */ var element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! element-ui/src/utils/popup/popup-manager */ "./node_modules/element-ui/src/utils/popup/popup-manager.js");
/* harmony import */ var _scrollbar_width__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scrollbar-width */ "./node_modules/element-ui/src/utils/scrollbar-width.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/element-ui/src/utils/dom.js");






let idSeed = 1;

let scrollBarWidth;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },

  beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].register(this._popupId, this);
  },

  beforeDestroy() {
    element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].deregister(this._popupId);
    element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].closeModal(this._popupId);

    this.restoreBodyStyle();
  },

  data() {
    return {
      opened: false,
      bodyPaddingRight: null,
      computedBodyPaddingRight: 0,
      withoutHiddenClass: true,
      rendered: false
    };
  },

  watch: {
    visible(val) {
      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          vue__WEBPACK_IMPORTED_MODULE_4__["default"].nextTick(() => {
            this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },

  methods: {
    open(options) {
      if (!this.rendered) {
        this.rendered = true;
      }

      const props = (0,element_ui_src_utils_merge__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.$props || this, options);

      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);

      const openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(() => {
          this._openTimer = null;
          this.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },

    doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;

      this._opening = true;

      const dom = this.$el;

      const modal = props.modal;

      const zIndex = props.zIndex;
      if (zIndex) {
        element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].zIndex = zIndex;
      }

      if (modal) {
        if (this._closing) {
          element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].closeModal(this._popupId);
          this._closing = false;
        }
        element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].openModal(this._popupId, element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);
        if (props.lockScroll) {
          this.withoutHiddenClass = !(0,_dom__WEBPACK_IMPORTED_MODULE_3__.hasClass)(document.body, 'el-popup-parent--hidden');
          if (this.withoutHiddenClass) {
            this.bodyPaddingRight = document.body.style.paddingRight;
            this.computedBodyPaddingRight = parseInt((0,_dom__WEBPACK_IMPORTED_MODULE_3__.getStyle)(document.body, 'paddingRight'), 10);
          }
          scrollBarWidth = (0,_scrollbar_width__WEBPACK_IMPORTED_MODULE_2__["default"])();
          let bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          let bodyOverflowY = (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getStyle)(document.body, 'overflowY');
          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {
            document.body.style.paddingRight = this.computedBodyPaddingRight + scrollBarWidth + 'px';
          }
          (0,_dom__WEBPACK_IMPORTED_MODULE_3__.addClass)(document.body, 'el-popup-parent--hidden');
        }
      }

      if (getComputedStyle(dom).position === 'static') {
        dom.style.position = 'absolute';
      }

      dom.style.zIndex = element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].nextZIndex();
      this.opened = true;

      this.onOpen && this.onOpen();

      this.doAfterOpen();
    },

    doAfterOpen() {
      this._opening = false;
    },

    close() {
      if (this.willClose && !this.willClose()) return;

      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);

      const closeDelay = Number(this.closeDelay);

      if (closeDelay > 0) {
        this._closeTimer = setTimeout(() => {
          this._closeTimer = null;
          this.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },

    doClose() {
      this._closing = true;

      this.onClose && this.onClose();

      if (this.lockScroll) {
        setTimeout(this.restoreBodyStyle, 200);
      }

      this.opened = false;

      this.doAfterClose();
    },

    doAfterClose() {
      element_ui_src_utils_popup_popup_manager__WEBPACK_IMPORTED_MODULE_1__["default"].closeModal(this._popupId);
      this._closing = false;
    },

    restoreBodyStyle() {
      if (this.modal && this.withoutHiddenClass) {
        document.body.style.paddingRight = this.bodyPaddingRight;
        (0,_dom__WEBPACK_IMPORTED_MODULE_3__.removeClass)(document.body, 'el-popup-parent--hidden');
      }
      this.withoutHiddenClass = true;
    }
  }
});




/***/ }),

/***/ "./node_modules/element-ui/src/utils/popup/popup-manager.js":
/*!******************************************************************!*\
  !*** ./node_modules/element-ui/src/utils/popup/popup-manager.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/dom */ "./node_modules/element-ui/src/utils/dom.js");



let hasModal = false;
let hasInitZIndex = false;
let zIndex;

const getModal = function() {
  if (vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer) return;
  let modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;

    modalDom.addEventListener('touchmove', function(event) {
      event.preventDefault();
      event.stopPropagation();
    });

    modalDom.addEventListener('click', function() {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }

  return modalDom;
};

const instances = {};

const PopupManager = {
  modalFade: true,

  getInstance: function(id) {
    return instances[id];
  },

  register: function(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },

  deregister: function(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },

  nextZIndex: function() {
    return PopupManager.zIndex++;
  },

  modalStack: [],

  doOnModalClick: function() {
    const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;

    const instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },

  openModal: function(id, zIndex, dom, modalClass, modalFade) {
    if (vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer) return;
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;

    const modalStack = this.modalStack;

    for (let i = 0, j = modalStack.length; i < j; i++) {
      const item = modalStack[i];
      if (item.id === id) {
        return;
      }
    }

    const modalDom = getModal();

    (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.addClass)(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.addClass)(modalDom, 'v-modal-enter');
    }
    if (modalClass) {
      let classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(item => (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.addClass)(modalDom, item));
    }
    setTimeout(() => {
      (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.removeClass)(modalDom, 'v-modal-enter');
    }, 200);

    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }

    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = '';

    this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
  },

  closeModal: function(id) {
    const modalStack = this.modalStack;
    const modalDom = getModal();

    if (modalStack.length > 0) {
      const topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          let classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(item => (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.removeClass)(modalDom, item));
        }

        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (let i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }

    if (modalStack.length === 0) {
      if (this.modalFade) {
        (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.addClass)(modalDom, 'v-modal-leave');
      }
      setTimeout(() => {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }
        (0,element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__.removeClass)(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};

Object.defineProperty(PopupManager, 'zIndex', {
  configurable: true,
  get() {
    if (!hasInitZIndex) {
      zIndex = zIndex || (vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$ELEMENT || {}).zIndex || 2000;
      hasInitZIndex = true;
    }
    return zIndex;
  },
  set(value) {
    zIndex = value;
  }
});

const getTopPopup = function() {
  if (vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    const instance = PopupManager.getInstance(topPopup.id);

    return instance;
  }
};

if (!vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function(event) {
    if (event.keyCode === 27) {
      const topPopup = getTopPopup();

      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose
          ? topPopup.handleClose()
          : (topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close());
      }
    }
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PopupManager);


/***/ }),

/***/ "./node_modules/element-ui/src/utils/scrollbar-width.js":
/*!**************************************************************!*\
  !*** ./node_modules/element-ui/src/utils/scrollbar-width.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");


let scrollBarWidth;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  if (vue__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;

  const outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);

  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';

  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);

  const widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;

  return scrollBarWidth;
};


/***/ }),

/***/ "./node_modules/element-ui/src/utils/shared.js":
/*!*****************************************************!*\
  !*** ./node_modules/element-ui/src/utils/shared.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDef": () => (/* binding */ isDef),
/* harmony export */   "isKorean": () => (/* binding */ isKorean)
/* harmony export */ });
function isDef(val) {
  return val !== undefined && val !== null;
}
function isKorean(text) {
  const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}


/***/ }),

/***/ "./node_modules/element-ui/src/utils/types.js":
/*!****************************************************!*\
  !*** ./node_modules/element-ui/src/utils/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isHtmlElement": () => (/* binding */ isHtmlElement),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");


function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
}

function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}

function isHtmlElement(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}

/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */
let isFunction = (functionToCheck) => {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
};

if ( true && typeof Int8Array !== 'object' && (vue__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.$isServer || typeof document.childNodes !== 'function')) {
  isFunction = function(obj) {
    return typeof obj === 'function' || false;
  };
}



const isUndefined = (val)=> {
  return val === void 0;
};

const isDefined = (val) => {
  return val !== undefined && val !== null;
};


/***/ }),

/***/ "./node_modules/element-ui/src/utils/util.js":
/*!***************************************************!*\
  !*** ./node_modules/element-ui/src/utils/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayEquals": () => (/* binding */ arrayEquals),
/* harmony export */   "arrayFind": () => (/* binding */ arrayFind),
/* harmony export */   "arrayFindIndex": () => (/* binding */ arrayFindIndex),
/* harmony export */   "autoprefixer": () => (/* binding */ autoprefixer),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "coerceTruthyValueToArray": () => (/* binding */ coerceTruthyValueToArray),
/* harmony export */   "escapeRegexpString": () => (/* binding */ escapeRegexpString),
/* harmony export */   "generateId": () => (/* binding */ generateId),
/* harmony export */   "getPropByPath": () => (/* binding */ getPropByPath),
/* harmony export */   "getValueByPath": () => (/* binding */ getValueByPath),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "isEdge": () => (/* binding */ isEdge),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "isFirefox": () => (/* binding */ isFirefox),
/* harmony export */   "isIE": () => (/* binding */ isIE),
/* harmony export */   "kebabCase": () => (/* binding */ kebabCase),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "noop": () => (/* binding */ noop),
/* harmony export */   "objToArray": () => (/* binding */ objToArray),
/* harmony export */   "rafThrottle": () => (/* binding */ rafThrottle),
/* harmony export */   "toObject": () => (/* binding */ toObject),
/* harmony export */   "valueEquals": () => (/* binding */ valueEquals)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var element_ui_src_utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/types */ "./node_modules/element-ui/src/utils/types.js");



const hasOwnProperty = Object.prototype.hasOwnProperty;

function noop() {};

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
};

function extend(to, _from) {
  for (let key in _from) {
    to[key] = _from[key];
  }
  return to;
};

function toObject(arr) {
  var res = {};
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
};

const getValueByPath = function(object, prop) {
  prop = prop || '';
  const paths = prop.split('.');
  let current = object;
  let result = null;
  for (let i = 0, j = paths.length; i < j; i++) {
    const path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};

function getPropByPath(obj, path, strict) {
  let tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');

  let keyArr = path.split('.');
  let i = 0;
  for (let len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    let key = keyArr[i];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
};

const generateId = function() {
  return Math.floor(Math.random() * 10000);
};

const valueEquals = (a, b) => {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};

const escapeRegexpString = (value = '') => String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');

// TODO: use native Array.find, Array.findIndex when IE support is dropped
const arrayFindIndex = function(arr, pred) {
  for (let i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
};

const arrayFind = function(arr, pred) {
  const idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
};

// coerce truthy value to array
const coerceTruthyValueToArray = function(val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};

const isIE = function() {
  return !vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer && !isNaN(Number(document.documentMode));
};

const isEdge = function() {
  return !vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;
};

const isFirefox = function() {
  return !vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);
};

const autoprefixer = function(style) {
  if (typeof style !== 'object') return style;
  const rules = ['transform', 'transition', 'animation'];
  const prefixes = ['ms-', 'webkit-'];
  rules.forEach(rule => {
    const value = style[rule];
    if (rule && value) {
      prefixes.forEach(prefix => {
        style[prefix + rule] = value;
      });
    }
  });
  return style;
};

const kebabCase = function(str) {
  const hyphenateRE = /([^-])([A-Z])/g;
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase();
};

const capitalize = function(str) {
  if (!(0,element_ui_src_utils_types__WEBPACK_IMPORTED_MODULE_0__.isString)(str)) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
};

const looseEqual = function(a, b) {
  const isObjectA = (0,element_ui_src_utils_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(a);
  const isObjectB = (0,element_ui_src_utils_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(b);
  if (isObjectA && isObjectB) {
    return JSON.stringify(a) === JSON.stringify(b);
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
};

const arrayEquals = function(arrayA, arrayB) {
  arrayA = arrayA || [];
  arrayB = arrayB || [];

  if (arrayA.length !== arrayB.length) {
    return false;
  }

  for (let i = 0; i < arrayA.length; i++) {
    if (!looseEqual(arrayA[i], arrayB[i])) {
      return false;
    }
  }

  return true;
};

const isEqual = function(value1, value2) {
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return arrayEquals(value1, value2);
  }
  return looseEqual(value1, value2);
};

const isEmpty = function(val) {
  // null or undefined
  if (val == null) return true;

  if (typeof val === 'boolean') return false;

  if (typeof val === 'number') return !val;

  if (val instanceof Error) return val.message === '';

  switch (Object.prototype.toString.call(val)) {
    // String or Array
    case '[object String]':
    case '[object Array]':
      return !val.length;

    // Map or Set or File
    case '[object File]':
    case '[object Map]':
    case '[object Set]': {
      return !val.size;
    }
    // Plain Object
    case '[object Object]': {
      return !Object.keys(val).length;
    }
  }

  return false;
};

function rafThrottle(fn) {
  let locked = false;
  return function(...args) {
    if (locked) return;
    locked = true;
    window.requestAnimationFrame(_ => {
      fn.apply(this, args);
      locked = false;
    });
  };
}

function objToArray(obj) {
  if (Array.isArray(obj)) {
    return obj;
  }
  return isEmpty(obj) ? [] : [obj];
}


/***/ }),

/***/ "./node_modules/element-ui/src/utils/vue-popper.js":
/*!*********************************************************!*\
  !*** ./node_modules/element-ui/src/utils/vue-popper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var element_ui_src_utils_popup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/utils/popup */ "./node_modules/element-ui/src/utils/popup/index.js");



const PopperJS = vue__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.$isServer ? function() {} : __webpack_require__(/*! ./popper */ "./node_modules/element-ui/src/utils/popper.js");
const stop = e => e.stopPropagation();

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    transformOrigin: {
      type: [Boolean, String],
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    arrowOffset: {
      type: Number,
      default: 35
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },

  data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },

  watch: {
    value: {
      immediate: true,
      handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },

    showPopper(val) {
      if (this.disabled) return;
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },

  methods: {
    createPopper() {
      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      const options = this.popperOptions;
      const popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      let reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference &&
        this.$slots.reference &&
        this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(_ => {
        this.$emit('created', this);
        this.resetTransformOrigin();
        this.$nextTick(this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = element_ui_src_utils_popup__WEBPACK_IMPORTED_MODULE_0__.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },

    updatePopper() {
      const popperJS = this.popperJS;
      if (popperJS) {
        popperJS.update();
        if (popperJS._popper) {
          popperJS._popper.style.zIndex = element_ui_src_utils_popup__WEBPACK_IMPORTED_MODULE_0__.PopupManager.nextZIndex();
        }
      } else {
        this.createPopper();
      }
    },

    doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!this.popperJS || (this.showPopper && !forceDestroy)) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },

    destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },

    resetTransformOrigin() {
      if (!this.transformOrigin) return;
      let placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      let placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      let origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string'
        ? this.transformOrigin
        : ['top', 'bottom'].indexOf(placement) > -1 ? `center ${ origin }` : `${ origin } center`;
    },

    appendArrow(element) {
      let hash;
      if (this.appended) {
        return;
      }

      this.appended = true;

      for (let item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      const arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },

  beforeDestroy() {
    this.doDestroy(true);
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },

  // call destroy in keep-alive mode
  deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
});


/***/ }),

/***/ "./node_modules/element-ui/packages/button/src/button.vue":
/*!****************************************************************!*\
  !*** ./node_modules/element-ui/packages/button/src/button.vue ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button.vue?vue&type=template&id=0c2dee2a& */ "./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a&");
/* harmony import */ var _button_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./button.vue?vue&type=script&lang=js& */ "./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _button_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__.render,
  _button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/element-ui/packages/button/src/button.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'ElButton',

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  props: {
    type: {
      type: String,
      default: 'default'
    },
    size: String,
    icon: {
      type: String,
      default: ''
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean
  },

  computed: {
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    buttonSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    buttonDisabled() {
      return this.$options.propsData.hasOwnProperty('disabled') ? this.disabled : (this.elForm || {}).disabled;
    }
  },

  methods: {
    handleClick(evt) {
      this.$emit('click', evt);
    }
  }
});


/***/ }),

/***/ "./node_modules/element-ui/packages/input/src/input.vue":
/*!**************************************************************!*\
  !*** ./node_modules/element-ui/packages/input/src/input.vue ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input.vue?vue&type=template&id=ed734b6a& */ "./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a&");
/* harmony import */ var _input_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input.vue?vue&type=script&lang=js& */ "./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _input_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__.render,
  _input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/element-ui/packages/input/src/input.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var element_ui_src_mixins_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! element-ui/src/mixins/emitter */ "./node_modules/element-ui/src/mixins/emitter.js");
/* harmony import */ var element_ui_src_mixins_migrating__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! element-ui/src/mixins/migrating */ "./node_modules/element-ui/src/mixins/migrating.js");
/* harmony import */ var _calcTextareaHeight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calcTextareaHeight */ "./node_modules/element-ui/packages/input/src/calcTextareaHeight.js");
/* harmony import */ var element_ui_src_utils_merge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! element-ui/src/utils/merge */ "./node_modules/element-ui/src/utils/merge.js");
/* harmony import */ var element_ui_src_utils_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! element-ui/src/utils/shared */ "./node_modules/element-ui/src/utils/shared.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'ElInput',

  componentName: 'ElInput',

  mixins: [element_ui_src_mixins_emitter__WEBPACK_IMPORTED_MODULE_0__["default"], element_ui_src_mixins_migrating__WEBPACK_IMPORTED_MODULE_1__["default"]],

  inheritAttrs: false,

  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  data() {
    return {
      textareaCalcStyle: {},
      hovering: false,
      focused: false,
      isComposing: false,
      passwordVisible: false
    };
  },

  props: {
    value: [String, Number],
    size: String,
    resize: String,
    form: String,
    disabled: Boolean,
    readonly: Boolean,
    type: {
      type: String,
      default: 'text'
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    autocomplete: {
      type: String,
      default: 'off'
    },
    /** @Deprecated in next major version */
    autoComplete: {
      type: String,
      validator(val) {
         true &&
          console.warn('[Element Warn][Input]\'auto-complete\' property will be deprecated in next major version. please use \'autocomplete\' instead.');
        return true;
      }
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    suffixIcon: String,
    prefixIcon: String,
    label: String,
    clearable: {
      type: Boolean,
      default: false
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    tabindex: String
  },

  computed: {
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    validateState() {
      return this.elFormItem ? this.elFormItem.validateState : '';
    },
    needStatusIcon() {
      return this.elForm ? this.elForm.statusIcon : false;
    },
    validateIcon() {
      return {
        validating: 'el-icon-loading',
        success: 'el-icon-circle-check',
        error: 'el-icon-circle-close'
      }[this.validateState];
    },
    textareaStyle() {
      return (0,element_ui_src_utils_merge__WEBPACK_IMPORTED_MODULE_3__["default"])({}, this.textareaCalcStyle, { resize: this.resize });
    },
    inputSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    inputDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    },
    nativeInputValue() {
      return this.value === null || this.value === undefined ? '' : String(this.value);
    },
    showClear() {
      return this.clearable &&
        !this.inputDisabled &&
        !this.readonly &&
        this.nativeInputValue &&
        (this.focused || this.hovering);
    },
    showPwdVisible() {
      return this.showPassword &&
        !this.inputDisabled &&
        !this.readonly &&
        (!!this.nativeInputValue || this.focused);
    },
    isWordLimitVisible() {
      return this.showWordLimit &&
        this.$attrs.maxlength &&
        (this.type === 'text' || this.type === 'textarea') &&
        !this.inputDisabled &&
        !this.readonly &&
        !this.showPassword;
    },
    upperLimit() {
      return this.$attrs.maxlength;
    },
    textLength() {
      if (typeof this.value === 'number') {
        return String(this.value).length;
      }

      return (this.value || '').length;
    },
    inputExceed() {
      // show exceed style if length of initial value greater then maxlength
      return this.isWordLimitVisible &&
        (this.textLength > this.upperLimit);
    }
  },

  watch: {
    value(val) {
      this.$nextTick(this.resizeTextarea);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', [val]);
      }
    },
    // native input value is set explicitly
    // do not use v-model / :value in template
    // see: https://github.com/ElemeFE/element/issues/14521
    nativeInputValue() {
      this.setNativeInputValue();
    },
    // when change between <input> and <textarea>,
    // update DOM dependent value and styles
    // https://github.com/ElemeFE/element/issues/14857
    type() {
      this.$nextTick(() => {
        this.setNativeInputValue();
        this.resizeTextarea();
        this.updateIconOffset();
      });
    }
  },

  methods: {
    focus() {
      this.getInput().focus();
    },
    blur() {
      this.getInput().blur();
    },
    getMigratingConfig() {
      return {
        props: {
          'icon': 'icon is removed, use suffix-icon / prefix-icon instead.',
          'on-icon-click': 'on-icon-click is removed.'
        },
        events: {
          'click': 'click is removed.'
        }
      };
    },
    handleBlur(event) {
      this.focused = false;
      this.$emit('blur', event);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.blur', [this.value]);
      }
    },
    select() {
      this.getInput().select();
    },
    resizeTextarea() {
      if (this.$isServer) return;
      const { autosize, type } = this;
      if (type !== 'textarea') return;
      if (!autosize) {
        this.textareaCalcStyle = {
          minHeight: (0,_calcTextareaHeight__WEBPACK_IMPORTED_MODULE_2__["default"])(this.$refs.textarea).minHeight
        };
        return;
      }
      const minRows = autosize.minRows;
      const maxRows = autosize.maxRows;

      this.textareaCalcStyle = (0,_calcTextareaHeight__WEBPACK_IMPORTED_MODULE_2__["default"])(this.$refs.textarea, minRows, maxRows);
    },
    setNativeInputValue() {
      const input = this.getInput();
      if (!input) return;
      if (input.value === this.nativeInputValue) return;
      input.value = this.nativeInputValue;
    },
    handleFocus(event) {
      this.focused = true;
      this.$emit('focus', event);
    },
    handleCompositionStart(event) {
      this.$emit('compositionstart', event);
      this.isComposing = true;
    },
    handleCompositionUpdate(event) {
      this.$emit('compositionupdate', event);
      const text = event.target.value;
      const lastCharacter = text[text.length - 1] || '';
      this.isComposing = !(0,element_ui_src_utils_shared__WEBPACK_IMPORTED_MODULE_4__.isKorean)(lastCharacter);
    },
    handleCompositionEnd(event) {
      this.$emit('compositionend', event);
      if (this.isComposing) {
        this.isComposing = false;
        this.handleInput(event);
      }
    },
    handleInput(event) {
      // should not emit input during composition
      // see: https://github.com/ElemeFE/element/issues/10516
      if (this.isComposing) return;

      // hack for https://github.com/ElemeFE/element/issues/8548
      // should remove the following line when we don't support IE
      if (event.target.value === this.nativeInputValue) return;

      this.$emit('input', event.target.value);

      // ensure native input value is controlled
      // see: https://github.com/ElemeFE/element/issues/12850
      this.$nextTick(this.setNativeInputValue);
    },
    handleChange(event) {
      this.$emit('change', event.target.value);
    },
    calcIconOffset(place) {
      let elList = [].slice.call(this.$el.querySelectorAll(`.el-input__${place}`) || []);
      if (!elList.length) return;
      let el = null;
      for (let i = 0; i < elList.length; i++) {
        if (elList[i].parentNode === this.$el) {
          el = elList[i];
          break;
        }
      }
      if (!el) return;
      const pendantMap = {
        suffix: 'append',
        prefix: 'prepend'
      };

      const pendant = pendantMap[place];
      if (this.$slots[pendant]) {
        el.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${this.$el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
      } else {
        el.removeAttribute('style');
      }
    },
    updateIconOffset() {
      this.calcIconOffset('prefix');
      this.calcIconOffset('suffix');
    },
    clear() {
      this.$emit('input', '');
      this.$emit('change', '');
      this.$emit('clear');
    },
    handlePasswordVisible() {
      this.passwordVisible = !this.passwordVisible;
      this.$nextTick(() => {
        this.focus();
      });
    },
    getInput() {
      return this.$refs.input || this.$refs.textarea;
    },
    getSuffixVisible() {
      return this.$slots.suffix ||
        this.suffixIcon ||
        this.showClear ||
        this.showPassword ||
        this.isWordLimitVisible ||
        (this.validateState && this.needStatusIcon);
    }
  },

  created() {
    this.$on('inputSelect', this.select);
  },

  mounted() {
    this.setNativeInputValue();
    this.resizeTextarea();
    this.updateIconOffset();
  },

  updated() {
    this.$nextTick(this.updateIconOffset);
  }
});


/***/ }),

/***/ "./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js&":
/*!*****************************************************************************************!*\
  !*** ./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js& ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_button_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../vue-loader/lib/index.js??vue-loader-options!./button.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_button_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a&":
/*!***********************************************************************************************!*\
  !*** ./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a& ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_button_vue_vue_type_template_id_0c2dee2a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../vue-loader/lib/index.js??vue-loader-options!./button.vue?vue&type=template&id=0c2dee2a& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a&");


/***/ }),

/***/ "./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js&":
/*!***************************************************************************************!*\
  !*** ./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a&":
/*!*********************************************************************************************!*\
  !*** ./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a& ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_template_id_ed734b6a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=template&id=ed734b6a& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a&":
/*!**************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/button/src/button.vue?vue&type=template&id=0c2dee2a& ***!
  \**************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "button",
    {
      staticClass: "el-button",
      class: [
        _vm.type ? "el-button--" + _vm.type : "",
        _vm.buttonSize ? "el-button--" + _vm.buttonSize : "",
        {
          "is-disabled": _vm.buttonDisabled,
          "is-loading": _vm.loading,
          "is-plain": _vm.plain,
          "is-round": _vm.round,
          "is-circle": _vm.circle,
        },
      ],
      attrs: {
        disabled: _vm.buttonDisabled || _vm.loading,
        autofocus: _vm.autofocus,
        type: _vm.nativeType,
      },
      on: { click: _vm.handleClick },
    },
    [
      _vm.loading ? _c("i", { staticClass: "el-icon-loading" }) : _vm._e(),
      _vm.icon && !_vm.loading ? _c("i", { class: _vm.icon }) : _vm._e(),
      _vm.$slots.default ? _c("span", [_vm._t("default")], 2) : _vm._e(),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/element-ui/packages/input/src/input.vue?vue&type=template&id=ed734b6a& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: [
        _vm.type === "textarea" ? "el-textarea" : "el-input",
        _vm.inputSize ? "el-input--" + _vm.inputSize : "",
        {
          "is-disabled": _vm.inputDisabled,
          "is-exceed": _vm.inputExceed,
          "el-input-group": _vm.$slots.prepend || _vm.$slots.append,
          "el-input-group--append": _vm.$slots.append,
          "el-input-group--prepend": _vm.$slots.prepend,
          "el-input--prefix": _vm.$slots.prefix || _vm.prefixIcon,
          "el-input--suffix":
            _vm.$slots.suffix ||
            _vm.suffixIcon ||
            _vm.clearable ||
            _vm.showPassword,
        },
      ],
      on: {
        mouseenter: function ($event) {
          _vm.hovering = true
        },
        mouseleave: function ($event) {
          _vm.hovering = false
        },
      },
    },
    [
      _vm.type !== "textarea"
        ? [
            _vm.$slots.prepend
              ? _c(
                  "div",
                  { staticClass: "el-input-group__prepend" },
                  [_vm._t("prepend")],
                  2
                )
              : _vm._e(),
            _vm.type !== "textarea"
              ? _c(
                  "input",
                  _vm._b(
                    {
                      ref: "input",
                      staticClass: "el-input__inner",
                      attrs: {
                        tabindex: _vm.tabindex,
                        type: _vm.showPassword
                          ? _vm.passwordVisible
                            ? "text"
                            : "password"
                          : _vm.type,
                        disabled: _vm.inputDisabled,
                        readonly: _vm.readonly,
                        autocomplete: _vm.autoComplete || _vm.autocomplete,
                        "aria-label": _vm.label,
                      },
                      on: {
                        compositionstart: _vm.handleCompositionStart,
                        compositionupdate: _vm.handleCompositionUpdate,
                        compositionend: _vm.handleCompositionEnd,
                        input: _vm.handleInput,
                        focus: _vm.handleFocus,
                        blur: _vm.handleBlur,
                        change: _vm.handleChange,
                      },
                    },
                    "input",
                    _vm.$attrs,
                    false
                  )
                )
              : _vm._e(),
            _vm.$slots.prefix || _vm.prefixIcon
              ? _c(
                  "span",
                  { staticClass: "el-input__prefix" },
                  [
                    _vm._t("prefix"),
                    _vm.prefixIcon
                      ? _c("i", {
                          staticClass: "el-input__icon",
                          class: _vm.prefixIcon,
                        })
                      : _vm._e(),
                  ],
                  2
                )
              : _vm._e(),
            _vm.getSuffixVisible()
              ? _c("span", { staticClass: "el-input__suffix" }, [
                  _c(
                    "span",
                    { staticClass: "el-input__suffix-inner" },
                    [
                      !_vm.showClear ||
                      !_vm.showPwdVisible ||
                      !_vm.isWordLimitVisible
                        ? [
                            _vm._t("suffix"),
                            _vm.suffixIcon
                              ? _c("i", {
                                  staticClass: "el-input__icon",
                                  class: _vm.suffixIcon,
                                })
                              : _vm._e(),
                          ]
                        : _vm._e(),
                      _vm.showClear
                        ? _c("i", {
                            staticClass:
                              "el-input__icon el-icon-circle-close el-input__clear",
                            on: {
                              mousedown: function ($event) {
                                $event.preventDefault()
                              },
                              click: _vm.clear,
                            },
                          })
                        : _vm._e(),
                      _vm.showPwdVisible
                        ? _c("i", {
                            staticClass:
                              "el-input__icon el-icon-view el-input__clear",
                            on: { click: _vm.handlePasswordVisible },
                          })
                        : _vm._e(),
                      _vm.isWordLimitVisible
                        ? _c("span", { staticClass: "el-input__count" }, [
                            _c(
                              "span",
                              { staticClass: "el-input__count-inner" },
                              [
                                _vm._v(
                                  "\n            " +
                                    _vm._s(_vm.textLength) +
                                    "/" +
                                    _vm._s(_vm.upperLimit) +
                                    "\n          "
                                ),
                              ]
                            ),
                          ])
                        : _vm._e(),
                    ],
                    2
                  ),
                  _vm.validateState
                    ? _c("i", {
                        staticClass: "el-input__icon",
                        class: ["el-input__validateIcon", _vm.validateIcon],
                      })
                    : _vm._e(),
                ])
              : _vm._e(),
            _vm.$slots.append
              ? _c(
                  "div",
                  { staticClass: "el-input-group__append" },
                  [_vm._t("append")],
                  2
                )
              : _vm._e(),
          ]
        : _c(
            "textarea",
            _vm._b(
              {
                ref: "textarea",
                staticClass: "el-textarea__inner",
                style: _vm.textareaStyle,
                attrs: {
                  tabindex: _vm.tabindex,
                  disabled: _vm.inputDisabled,
                  readonly: _vm.readonly,
                  autocomplete: _vm.autoComplete || _vm.autocomplete,
                  "aria-label": _vm.label,
                },
                on: {
                  compositionstart: _vm.handleCompositionStart,
                  compositionupdate: _vm.handleCompositionUpdate,
                  compositionend: _vm.handleCompositionEnd,
                  input: _vm.handleInput,
                  focus: _vm.handleFocus,
                  blur: _vm.handleBlur,
                  change: _vm.handleChange,
                },
              },
              "textarea",
              _vm.$attrs,
              false
            )
          ),
      _vm.isWordLimitVisible && _vm.type === "textarea"
        ? _c("span", { staticClass: "el-input__count" }, [
            _vm._v(_vm._s(_vm.textLength) + "/" + _vm._s(_vm.upperLimit)),
          ])
        : _vm._e(),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZWxlbWVudC11aV9wYWNrYWdlc19idXR0b25faW5kZXhfanMtbm9kZV9tb2R1bGVzX2VsZW1lbnQtdWlfcGFja2FnZXNfaW5wLTU2NzYxZC4yNTkzYTQ2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBLDJEQUFnQjtBQUNoQixnQkFBZ0Isd0RBQWEsRUFBRSxtREFBUTtBQUN2Qzs7QUFFQSxpRUFBZSxtREFBUSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1BVOztBQUVsQztBQUNBLDBEQUFlO0FBQ2YsZ0JBQWdCLHVEQUFZLEVBQUUsa0RBQU87QUFDckM7O0FBRUEsaUVBQWUsa0RBQU8sRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1B2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEtBQUssR0FBRyw2QkFBNkI7QUFDekQsWUFBWTs7QUFFWixXQUFXO0FBQ1g7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLDBDQUEwQyxjQUFjLEVBQUUsYUFBYTtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNB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O0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7QUMzRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJO0FBQzdDO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0Isd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsRUFBRTtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUE2QjtBQUNuQztBQUNBLElBQUksU0FBUyxJQUEwQztBQUN2RCxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTixJQUFJLEtBQUssRUFFTjtBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9XRDs7QUFFc0I7O0FBRXRCLGlCQUFpQiwrREFBdUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsT0EsNkJBQWUsb0NBQVM7QUFDeEIsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztB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QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdGJrSCxDQUFDLGlFQUFlLHVIQUFHLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRUFyQixDQUFDLGlFQUFlLHNIQUFHLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRUFySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsWUFBWSx3QkFBd0I7QUFDcEMsS0FBSztBQUNMO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBO0FBQ0EsZ0NBQWdDLHNDQUFzQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvYnV0dG9uL2luZGV4LmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvaW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9wYWNrYWdlcy9pbnB1dC9zcmMvY2FsY1RleHRhcmVhSGVpZ2h0LmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL2xvY2FsZS9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvbG9jYWxlL2luZGV4LmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL2xvY2FsZS9sYW5nL3poLUNOLmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL21peGlucy9lbWl0dGVyLmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL21peGlucy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvbWl4aW5zL21pZ3JhdGluZy5qcyIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3NyYy91dGlscy9jbGlja291dHNpZGUuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvdXRpbHMvZGF0ZS5qcyIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3NyYy91dGlscy9kb20uanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvdXRpbHMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvdXRpbHMvcG9wcGVyLmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL3V0aWxzL3BvcHVwL2luZGV4LmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL3V0aWxzL3BvcHVwL3BvcHVwLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9zcmMvdXRpbHMvc2Nyb2xsYmFyLXdpZHRoLmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL3V0aWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3NyYy91dGlscy90eXBlcy5qcyIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3NyYy91dGlscy91dGlsLmpzIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvc3JjL3V0aWxzL3Z1ZS1wb3BwZXIuanMiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9wYWNrYWdlcy9idXR0b24vc3JjL2J1dHRvbi52dWUiLCJ3ZWJwYWNrOi8veXh0eC1saWIvbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvYnV0dG9uL3NyYy9idXR0b24udnVlIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvaW5wdXQvc3JjL2lucHV0LnZ1ZSIsIndlYnBhY2s6Ly95eHR4LWxpYi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9wYWNrYWdlcy9pbnB1dC9zcmMvaW5wdXQudnVlIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvYnV0dG9uL3NyYy9idXR0b24udnVlPzk0OGYiLCJ3ZWJwYWNrOi8veXh0eC1saWIvLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9wYWNrYWdlcy9idXR0b24vc3JjL2J1dHRvbi52dWU/MWQwZiIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3BhY2thZ2VzL2lucHV0L3NyYy9pbnB1dC52dWU/ZjYzMSIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3BhY2thZ2VzL2lucHV0L3NyYy9pbnB1dC52dWU/MDE0NyIsIndlYnBhY2s6Ly95eHR4LWxpYi8uL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3BhY2thZ2VzL2J1dHRvbi9zcmMvYnV0dG9uLnZ1ZT9kNjUwIiwid2VicGFjazovL3l4dHgtbGliLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvaW5wdXQvc3JjL2lucHV0LnZ1ZT85Mjc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFbEJ1dHRvbiBmcm9tICcuL3NyYy9idXR0b24nO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuRWxCdXR0b24uaW5zdGFsbCA9IGZ1bmN0aW9uKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KEVsQnV0dG9uLm5hbWUsIEVsQnV0dG9uKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVsQnV0dG9uO1xuIiwiaW1wb3J0IEVsSW5wdXQgZnJvbSAnLi9zcmMvaW5wdXQnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuRWxJbnB1dC5pbnN0YWxsID0gZnVuY3Rpb24oVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQoRWxJbnB1dC5uYW1lLCBFbElucHV0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVsSW5wdXQ7XG4iLCJsZXQgaGlkZGVuVGV4dGFyZWE7XG5cbmNvbnN0IEhJRERFTl9TVFlMRSA9IGBcbiAgaGVpZ2h0OjAgIWltcG9ydGFudDtcbiAgdmlzaWJpbGl0eTpoaWRkZW4gIWltcG9ydGFudDtcbiAgb3ZlcmZsb3c6aGlkZGVuICFpbXBvcnRhbnQ7XG4gIHBvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7XG4gIHotaW5kZXg6LTEwMDAgIWltcG9ydGFudDtcbiAgdG9wOjAgIWltcG9ydGFudDtcbiAgcmlnaHQ6MCAhaW1wb3J0YW50XG5gO1xuXG5jb25zdCBDT05URVhUX1NUWUxFID0gW1xuICAnbGV0dGVyLXNwYWNpbmcnLFxuICAnbGluZS1oZWlnaHQnLFxuICAncGFkZGluZy10b3AnLFxuICAncGFkZGluZy1ib3R0b20nLFxuICAnZm9udC1mYW1pbHknLFxuICAnZm9udC13ZWlnaHQnLFxuICAnZm9udC1zaXplJyxcbiAgJ3RleHQtcmVuZGVyaW5nJyxcbiAgJ3RleHQtdHJhbnNmb3JtJyxcbiAgJ3dpZHRoJyxcbiAgJ3RleHQtaW5kZW50JyxcbiAgJ3BhZGRpbmctbGVmdCcsXG4gICdwYWRkaW5nLXJpZ2h0JyxcbiAgJ2JvcmRlci13aWR0aCcsXG4gICdib3gtc2l6aW5nJ1xuXTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVN0eWxpbmcodGFyZ2V0RWxlbWVudCkge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpO1xuXG4gIGNvbnN0IGJveFNpemluZyA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcblxuICBjb25zdCBwYWRkaW5nU2l6ZSA9IChcbiAgICBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpICtcbiAgICBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctdG9wJykpXG4gICk7XG5cbiAgY29uc3QgYm9yZGVyU2l6ZSA9IChcbiAgICBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKSkgK1xuICAgIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpKVxuICApO1xuXG4gIGNvbnN0IGNvbnRleHRTdHlsZSA9IENPTlRFWFRfU1RZTEVcbiAgICAubWFwKG5hbWUgPT4gYCR7bmFtZX06JHtzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpfWApXG4gICAgLmpvaW4oJzsnKTtcblxuICByZXR1cm4geyBjb250ZXh0U3R5bGUsIHBhZGRpbmdTaXplLCBib3JkZXJTaXplLCBib3hTaXppbmcgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FsY1RleHRhcmVhSGVpZ2h0KFxuICB0YXJnZXRFbGVtZW50LFxuICBtaW5Sb3dzID0gMSxcbiAgbWF4Um93cyA9IG51bGxcbikge1xuICBpZiAoIWhpZGRlblRleHRhcmVhKSB7XG4gICAgaGlkZGVuVGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuVGV4dGFyZWEpO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwYWRkaW5nU2l6ZSxcbiAgICBib3JkZXJTaXplLFxuICAgIGJveFNpemluZyxcbiAgICBjb250ZXh0U3R5bGVcbiAgfSA9IGNhbGN1bGF0ZU5vZGVTdHlsaW5nKHRhcmdldEVsZW1lbnQpO1xuXG4gIGhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgJHtjb250ZXh0U3R5bGV9OyR7SElEREVOX1NUWUxFfWApO1xuICBoaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRhcmdldEVsZW1lbnQudmFsdWUgfHwgdGFyZ2V0RWxlbWVudC5wbGFjZWhvbGRlciB8fCAnJztcblxuICBsZXQgaGVpZ2h0ID0gaGlkZGVuVGV4dGFyZWEuc2Nyb2xsSGVpZ2h0O1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICBpZiAoYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcbiAgICBoZWlnaHQgPSBoZWlnaHQgKyBib3JkZXJTaXplO1xuICB9IGVsc2UgaWYgKGJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGhlaWdodCA9IGhlaWdodCAtIHBhZGRpbmdTaXplO1xuICB9XG5cbiAgaGlkZGVuVGV4dGFyZWEudmFsdWUgPSAnJztcbiAgbGV0IHNpbmdsZVJvd0hlaWdodCA9IGhpZGRlblRleHRhcmVhLnNjcm9sbEhlaWdodCAtIHBhZGRpbmdTaXplO1xuXG4gIGlmIChtaW5Sb3dzICE9PSBudWxsKSB7XG4gICAgbGV0IG1pbkhlaWdodCA9IHNpbmdsZVJvd0hlaWdodCAqIG1pblJvd3M7XG4gICAgaWYgKGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgICBtaW5IZWlnaHQgPSBtaW5IZWlnaHQgKyBwYWRkaW5nU2l6ZSArIGJvcmRlclNpemU7XG4gICAgfVxuICAgIGhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgaGVpZ2h0KTtcbiAgICByZXN1bHQubWluSGVpZ2h0ID0gYCR7IG1pbkhlaWdodCB9cHhgO1xuICB9XG4gIGlmIChtYXhSb3dzICE9PSBudWxsKSB7XG4gICAgbGV0IG1heEhlaWdodCA9IHNpbmdsZVJvd0hlaWdodCAqIG1heFJvd3M7XG4gICAgaWYgKGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgICBtYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBwYWRkaW5nU2l6ZSArIGJvcmRlclNpemU7XG4gICAgfVxuICAgIGhlaWdodCA9IE1hdGgubWluKG1heEhlaWdodCwgaGVpZ2h0KTtcbiAgfVxuICByZXN1bHQuaGVpZ2h0ID0gYCR7IGhlaWdodCB9cHhgO1xuICBoaWRkZW5UZXh0YXJlYS5wYXJlbnROb2RlICYmIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlkZGVuVGV4dGFyZWEpO1xuICBoaWRkZW5UZXh0YXJlYSA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IHsgaGFzT3duIH0gZnJvbSAnZWxlbWVudC11aS9zcmMvdXRpbHMvdXRpbCc7XG5cbmNvbnN0IFJFX05BUkdTID0gLyglfClcXHsoWzAtOWEtekEtWl9dKylcXH0vZztcbi8qKlxuICogIFN0cmluZyBmb3JtYXQgdGVtcGxhdGVcbiAqICAtIEluc3BpcmVkOlxuICogICAgaHR0cHM6Ly9naXRodWIuY29tL01hdHQtRXNjaC9zdHJpbmctdGVtcGxhdGUvaW5kZXguanNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVnVlKSB7XG5cbiAgLyoqXG4gICAqIHRlbXBsYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtBcnJheX0gLi4uYXJnc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmICghYXJncyB8fCAhYXJncy5oYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgYXJncyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShSRV9OQVJHUywgKG1hdGNoLCBwcmVmaXgsIGksIGluZGV4KSA9PiB7XG4gICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nW2luZGV4IC0gMV0gPT09ICd7JyAmJlxuICAgICAgICBzdHJpbmdbaW5kZXggKyBtYXRjaC5sZW5ndGhdID09PSAnfScpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBoYXNPd24oYXJncywgaSkgPyBhcmdzW2ldIDogbnVsbDtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG4iLCJpbXBvcnQgZGVmYXVsdExhbmcgZnJvbSAnZWxlbWVudC11aS9zcmMvbG9jYWxlL2xhbmcvemgtQ04nO1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IEZvcm1hdCBmcm9tICcuL2Zvcm1hdCc7XG5cbmNvbnN0IGZvcm1hdCA9IEZvcm1hdChWdWUpO1xubGV0IGxhbmcgPSBkZWZhdWx0TGFuZztcbmxldCBtZXJnZWQgPSBmYWxzZTtcbmxldCBpMThuSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB2dWVpMThuID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMgfHwgVnVlKS4kdDtcbiAgaWYgKHR5cGVvZiB2dWVpMThuID09PSAnZnVuY3Rpb24nICYmICEhVnVlLmxvY2FsZSkge1xuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgVnVlLmxvY2FsZShcbiAgICAgICAgVnVlLmNvbmZpZy5sYW5nLFxuICAgICAgICBkZWVwbWVyZ2UobGFuZywgVnVlLmxvY2FsZShWdWUuY29uZmlnLmxhbmcpIHx8IHt9LCB7IGNsb25lOiB0cnVlIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdnVlaTE4bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdCA9IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgbGV0IHZhbHVlID0gaTE4bkhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHJldHVybiB2YWx1ZTtcblxuICBjb25zdCBhcnJheSA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1cnJlbnQgPSBsYW5nO1xuXG4gIGZvciAobGV0IGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBhcnJheVtpXTtcbiAgICB2YWx1ZSA9IGN1cnJlbnRbcHJvcGVydHldO1xuICAgIGlmIChpID09PSBqIC0gMSkgcmV0dXJuIGZvcm1hdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuICcnO1xuICAgIGN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlID0gZnVuY3Rpb24obCkge1xuICBsYW5nID0gbCB8fCBsYW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IGkxOG4gPSBmdW5jdGlvbihmbikge1xuICBpMThuSGFuZGxlciA9IGZuIHx8IGkxOG5IYW5kbGVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgeyB1c2UsIHQsIGkxOG4gfTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZWw6IHtcbiAgICBjb2xvcnBpY2tlcjoge1xuICAgICAgY29uZmlybTogJ+ehruWumicsXG4gICAgICBjbGVhcjogJ+a4heepuidcbiAgICB9LFxuICAgIGRhdGVwaWNrZXI6IHtcbiAgICAgIG5vdzogJ+atpOWIuycsXG4gICAgICB0b2RheTogJ+S7iuWkqScsXG4gICAgICBjYW5jZWw6ICflj5bmtognLFxuICAgICAgY2xlYXI6ICfmuIXnqbonLFxuICAgICAgY29uZmlybTogJ+ehruWumicsXG4gICAgICBzZWxlY3REYXRlOiAn6YCJ5oup5pel5pyfJyxcbiAgICAgIHNlbGVjdFRpbWU6ICfpgInmi6nml7bpl7QnLFxuICAgICAgc3RhcnREYXRlOiAn5byA5aeL5pel5pyfJyxcbiAgICAgIHN0YXJ0VGltZTogJ+W8gOWni+aXtumXtCcsXG4gICAgICBlbmREYXRlOiAn57uT5p2f5pel5pyfJyxcbiAgICAgIGVuZFRpbWU6ICfnu5PmnZ/ml7bpl7QnLFxuICAgICAgcHJldlllYXI6ICfliY3kuIDlubQnLFxuICAgICAgbmV4dFllYXI6ICflkI7kuIDlubQnLFxuICAgICAgcHJldk1vbnRoOiAn5LiK5Liq5pyIJyxcbiAgICAgIG5leHRNb250aDogJ+S4i+S4quaciCcsXG4gICAgICB5ZWFyOiAn5bm0JyxcbiAgICAgIG1vbnRoMTogJzEg5pyIJyxcbiAgICAgIG1vbnRoMjogJzIg5pyIJyxcbiAgICAgIG1vbnRoMzogJzMg5pyIJyxcbiAgICAgIG1vbnRoNDogJzQg5pyIJyxcbiAgICAgIG1vbnRoNTogJzUg5pyIJyxcbiAgICAgIG1vbnRoNjogJzYg5pyIJyxcbiAgICAgIG1vbnRoNzogJzcg5pyIJyxcbiAgICAgIG1vbnRoODogJzgg5pyIJyxcbiAgICAgIG1vbnRoOTogJzkg5pyIJyxcbiAgICAgIG1vbnRoMTA6ICcxMCDmnIgnLFxuICAgICAgbW9udGgxMTogJzExIOaciCcsXG4gICAgICBtb250aDEyOiAnMTIg5pyIJyxcbiAgICAgIC8vIHdlZWs6ICflkajmrKEnLFxuICAgICAgd2Vla3M6IHtcbiAgICAgICAgc3VuOiAn5pelJyxcbiAgICAgICAgbW9uOiAn5LiAJyxcbiAgICAgICAgdHVlOiAn5LqMJyxcbiAgICAgICAgd2VkOiAn5LiJJyxcbiAgICAgICAgdGh1OiAn5ZubJyxcbiAgICAgICAgZnJpOiAn5LqUJyxcbiAgICAgICAgc2F0OiAn5YWtJ1xuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICBqYW46ICfkuIDmnIgnLFxuICAgICAgICBmZWI6ICfkuozmnIgnLFxuICAgICAgICBtYXI6ICfkuInmnIgnLFxuICAgICAgICBhcHI6ICflm5vmnIgnLFxuICAgICAgICBtYXk6ICfkupTmnIgnLFxuICAgICAgICBqdW46ICflha3mnIgnLFxuICAgICAgICBqdWw6ICfkuIPmnIgnLFxuICAgICAgICBhdWc6ICflhavmnIgnLFxuICAgICAgICBzZXA6ICfkuZ3mnIgnLFxuICAgICAgICBvY3Q6ICfljYHmnIgnLFxuICAgICAgICBub3Y6ICfljYHkuIDmnIgnLFxuICAgICAgICBkZWM6ICfljYHkuozmnIgnXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGxvYWRpbmc6ICfliqDovb3kuK0nLFxuICAgICAgbm9NYXRjaDogJ+aXoOWMuemFjeaVsOaNricsXG4gICAgICBub0RhdGE6ICfml6DmlbDmja4nLFxuICAgICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6knXG4gICAgfSxcbiAgICBjYXNjYWRlcjoge1xuICAgICAgbm9NYXRjaDogJ+aXoOWMuemFjeaVsOaNricsXG4gICAgICBsb2FkaW5nOiAn5Yqg6L295LitJyxcbiAgICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oupJyxcbiAgICAgIG5vRGF0YTogJ+aaguaXoOaVsOaNridcbiAgICB9LFxuICAgIHBhZ2luYXRpb246IHtcbiAgICAgIGdvdG86ICfliY3lvoAnLFxuICAgICAgcGFnZXNpemU6ICfmnaEv6aG1JyxcbiAgICAgIHRvdGFsOiAn5YWxIHt0b3RhbH0g5p2hJyxcbiAgICAgIHBhZ2VDbGFzc2lmaWVyOiAn6aG1J1xuICAgIH0sXG4gICAgbWVzc2FnZWJveDoge1xuICAgICAgdGl0bGU6ICfmj5DnpLonLFxuICAgICAgY29uZmlybTogJ+ehruWumicsXG4gICAgICBjYW5jZWw6ICflj5bmtognLFxuICAgICAgZXJyb3I6ICfovpPlhaXnmoTmlbDmja7kuI3lkIjms5UhJ1xuICAgIH0sXG4gICAgdXBsb2FkOiB7XG4gICAgICBkZWxldGVUaXA6ICfmjIkgZGVsZXRlIOmUruWPr+WIoOmZpCcsXG4gICAgICBkZWxldGU6ICfliKDpmaQnLFxuICAgICAgcHJldmlldzogJ+afpeeci+WbvueJhycsXG4gICAgICBjb250aW51ZTogJ+e7p+e7reS4iuS8oCdcbiAgICB9LFxuICAgIHRhYmxlOiB7XG4gICAgICBlbXB0eVRleHQ6ICfmmoLml6DmlbDmja4nLFxuICAgICAgY29uZmlybUZpbHRlcjogJ+etm+mAiScsXG4gICAgICByZXNldEZpbHRlcjogJ+mHjee9ricsXG4gICAgICBjbGVhckZpbHRlcjogJ+WFqOmDqCcsXG4gICAgICBzdW1UZXh0OiAn5ZCI6K6hJ1xuICAgIH0sXG4gICAgdHJlZToge1xuICAgICAgZW1wdHlUZXh0OiAn5pqC5peg5pWw5o2uJ1xuICAgIH0sXG4gICAgdHJhbnNmZXI6IHtcbiAgICAgIG5vTWF0Y2g6ICfml6DljLnphY3mlbDmja4nLFxuICAgICAgbm9EYXRhOiAn5peg5pWw5o2uJyxcbiAgICAgIHRpdGxlczogWyfliJfooaggMScsICfliJfooaggMiddLFxuICAgICAgZmlsdGVyUGxhY2Vob2xkZXI6ICfor7fovpPlhaXmkJzntKLlhoXlrrknLFxuICAgICAgbm9DaGVja2VkRm9ybWF0OiAn5YWxIHt0b3RhbH0g6aG5JyxcbiAgICAgIGhhc0NoZWNrZWRGb3JtYXQ6ICflt7LpgIkge2NoZWNrZWR9L3t0b3RhbH0g6aG5J1xuICAgIH0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIGVycm9yOiAn5Yqg6L295aSx6LSlJ1xuICAgIH0sXG4gICAgcGFnZUhlYWRlcjoge1xuICAgICAgdGl0bGU6ICfov5Tlm54nXG4gICAgfSxcbiAgICBwb3Bjb25maXJtOiB7XG4gICAgICBjb25maXJtQnV0dG9uVGV4dDogJ+ehruWumicsXG4gICAgICBjYW5jZWxCdXR0b25UZXh0OiAn5Y+W5raIJ1xuICAgIH0sXG4gICAgZW1wdHk6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiAn5pqC5peg5pWw5o2uJ1xuICAgIH1cbiAgfVxufTtcbiIsImZ1bmN0aW9uIGJyb2FkY2FzdChjb21wb25lbnROYW1lLCBldmVudE5hbWUsIHBhcmFtcykge1xuICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICB2YXIgbmFtZSA9IGNoaWxkLiRvcHRpb25zLmNvbXBvbmVudE5hbWU7XG5cbiAgICBpZiAobmFtZSA9PT0gY29tcG9uZW50TmFtZSkge1xuICAgICAgY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIFtldmVudE5hbWVdLmNvbmNhdChwYXJhbXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJvYWRjYXN0LmFwcGx5KGNoaWxkLCBbY29tcG9uZW50TmFtZSwgZXZlbnROYW1lXS5jb25jYXQoW3BhcmFtc10pKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQge1xuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2goY29tcG9uZW50TmFtZSwgZXZlbnROYW1lLCBwYXJhbXMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQgfHwgdGhpcy4kcm9vdDtcbiAgICAgIHZhciBuYW1lID0gcGFyZW50LiRvcHRpb25zLmNvbXBvbmVudE5hbWU7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgKCFuYW1lIHx8IG5hbWUgIT09IGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBuYW1lID0gcGFyZW50LiRvcHRpb25zLmNvbXBvbmVudE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgW2V2ZW50TmFtZV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYnJvYWRjYXN0KGNvbXBvbmVudE5hbWUsIGV2ZW50TmFtZSwgcGFyYW1zKSB7XG4gICAgICBicm9hZGNhc3QuY2FsbCh0aGlzLCBjb21wb25lbnROYW1lLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgdCB9IGZyb20gJ2VsZW1lbnQtdWkvc3JjL2xvY2FsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWV0aG9kczoge1xuICAgIHQoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnZWxlbWVudC11aS9zcmMvdXRpbHMvdXRpbCc7XG4vKipcbiAqIFNob3cgbWlncmF0aW5nIGd1aWRlIGluIGJyb3dzZXIgY29uc29sZS5cbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCBNaWdyYXRpbmcgZnJvbSAnZWxlbWVudC11aS9zcmMvbWl4aW5zL21pZ3JhdGluZyc7XG4gKlxuICogbWl4aW5zOiBbTWlncmF0aW5nXVxuICpcbiAqIGFkZCBnZXRNaWdyYXRpbmdDb25maWcgbWV0aG9kIGZvciB5b3VyIGNvbXBvbmVudC5cbiAqICBnZXRNaWdyYXRpbmdDb25maWcoKSB7XG4gKiAgICByZXR1cm4ge1xuICogICAgICBwcm9wczoge1xuICogICAgICAgICdhbGxvdy1uby1zZWxlY3Rpb24nOiAnYWxsb3ctbm8tc2VsZWN0aW9uIGlzIHJlbW92ZWQuJyxcbiAqICAgICAgICAnc2VsZWN0aW9uLW1vZGUnOiAnc2VsZWN0aW9uLW1vZGUgaXMgcmVtb3ZlZC4nXG4gKiAgICAgIH0sXG4gKiAgICAgIGV2ZW50czoge1xuICogICAgICAgIHNlbGVjdGlvbmNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZSBpcyByZW5hbWVkIHRvIHNlbGVjdGlvbi1jaGFuZ2UuJ1xuICogICAgICB9XG4gKiAgICB9O1xuICogIH0sXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbW91bnRlZCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykgcmV0dXJuO1xuICAgIGlmICghdGhpcy4kdm5vZGUpIHJldHVybjtcbiAgICBjb25zdCB7IHByb3BzID0ge30sIGV2ZW50cyA9IHt9IH0gPSB0aGlzLmdldE1pZ3JhdGluZ0NvbmZpZygpO1xuICAgIGNvbnN0IHsgZGF0YSwgY29tcG9uZW50T3B0aW9ucyB9ID0gdGhpcy4kdm5vZGU7XG4gICAgY29uc3QgZGVmaW5lZFByb3BzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICBjb25zdCBkZWZpbmVkRXZlbnRzID0gY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMgfHwge307XG5cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBkZWZpbmVkUHJvcHMpIHtcbiAgICAgIHByb3BOYW1lID0ga2ViYWJDYXNlKHByb3BOYW1lKTsgLy8gY29tcGF0aWJsZSB3aXRoIGNhbWVsIGNhc2VcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbRWxlbWVudCBNaWdyYXRpbmddWyR7dGhpcy4kb3B0aW9ucy5uYW1lfV1bQXR0cmlidXRlXTogJHtwcm9wc1twcm9wTmFtZV19YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgZXZlbnROYW1lIGluIGRlZmluZWRFdmVudHMpIHtcbiAgICAgIGV2ZW50TmFtZSA9IGtlYmFiQ2FzZShldmVudE5hbWUpOyAvLyBjb21wYXRpYmxlIHdpdGggY2FtZWwgY2FzZVxuICAgICAgaWYgKGV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0VsZW1lbnQgTWlncmF0aW5nXVske3RoaXMuJG9wdGlvbnMubmFtZX1dW0V2ZW50XTogJHtldmVudHNbZXZlbnROYW1lXX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRNaWdyYXRpbmdDb25maWcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge30sXG4gICAgICAgIGV2ZW50czoge31cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgb24gfSBmcm9tICdlbGVtZW50LXVpL3NyYy91dGlscy9kb20nO1xuXG5jb25zdCBub2RlTGlzdCA9IFtdO1xuY29uc3QgY3R4ID0gJ0BAY2xpY2tvdXRzaWRlQ29udGV4dCc7XG5cbmxldCBzdGFydENsaWNrO1xubGV0IHNlZWQgPSAwO1xuXG4hVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgb24oZG9jdW1lbnQsICdtb3VzZWRvd24nLCBlID0+IChzdGFydENsaWNrID0gZSkpO1xuXG4hVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgb24oZG9jdW1lbnQsICdtb3VzZXVwJywgZSA9PiB7XG4gIG5vZGVMaXN0LmZvckVhY2gobm9kZSA9PiBub2RlW2N0eF0uZG9jdW1lbnRIYW5kbGVyKGUsIHN0YXJ0Q2xpY2spKTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEhhbmRsZXIoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihtb3VzZXVwID0ge30sIG1vdXNlZG93biA9IHt9KSB7XG4gICAgaWYgKCF2bm9kZSB8fFxuICAgICAgIXZub2RlLmNvbnRleHQgfHxcbiAgICAgICFtb3VzZXVwLnRhcmdldCB8fFxuICAgICAgIW1vdXNlZG93bi50YXJnZXQgfHxcbiAgICAgIGVsLmNvbnRhaW5zKG1vdXNldXAudGFyZ2V0KSB8fFxuICAgICAgZWwuY29udGFpbnMobW91c2Vkb3duLnRhcmdldCkgfHxcbiAgICAgIGVsID09PSBtb3VzZXVwLnRhcmdldCB8fFxuICAgICAgKHZub2RlLmNvbnRleHQucG9wcGVyRWxtICYmXG4gICAgICAodm5vZGUuY29udGV4dC5wb3BwZXJFbG0uY29udGFpbnMobW91c2V1cC50YXJnZXQpIHx8XG4gICAgICB2bm9kZS5jb250ZXh0LnBvcHBlckVsbS5jb250YWlucyhtb3VzZWRvd24udGFyZ2V0KSkpKSByZXR1cm47XG5cbiAgICBpZiAoYmluZGluZy5leHByZXNzaW9uICYmXG4gICAgICBlbFtjdHhdLm1ldGhvZE5hbWUgJiZcbiAgICAgIHZub2RlLmNvbnRleHRbZWxbY3R4XS5tZXRob2ROYW1lXSkge1xuICAgICAgdm5vZGUuY29udGV4dFtlbFtjdHhdLm1ldGhvZE5hbWVdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsW2N0eF0uYmluZGluZ0ZuICYmIGVsW2N0eF0uYmluZGluZ0ZuKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIHYtY2xpY2tvdXRzaWRlXG4gKiBAZGVzYyDngrnlh7vlhYPntKDlpJbpnaLmiY3kvJrop6blj5HnmoTkuovku7ZcbiAqIEBleGFtcGxlXG4gKiBgYGB2dWVcbiAqIDxkaXYgdi1lbGVtZW50LWNsaWNrb3V0c2lkZT1cImhhbmRsZUNsb3NlXCI+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBiaW5kKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIG5vZGVMaXN0LnB1c2goZWwpO1xuICAgIGNvbnN0IGlkID0gc2VlZCsrO1xuICAgIGVsW2N0eF0gPSB7XG4gICAgICBpZCxcbiAgICAgIGRvY3VtZW50SGFuZGxlcjogY3JlYXRlRG9jdW1lbnRIYW5kbGVyKGVsLCBiaW5kaW5nLCB2bm9kZSksXG4gICAgICBtZXRob2ROYW1lOiBiaW5kaW5nLmV4cHJlc3Npb24sXG4gICAgICBiaW5kaW5nRm46IGJpbmRpbmcudmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFtjdHhdLmRvY3VtZW50SGFuZGxlciA9IGNyZWF0ZURvY3VtZW50SGFuZGxlcihlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIGVsW2N0eF0ubWV0aG9kTmFtZSA9IGJpbmRpbmcuZXhwcmVzc2lvbjtcbiAgICBlbFtjdHhdLmJpbmRpbmdGbiA9IGJpbmRpbmcudmFsdWU7XG4gIH0sXG5cbiAgdW5iaW5kKGVsKSB7XG4gICAgbGV0IGxlbiA9IG5vZGVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2RlTGlzdFtpXVtjdHhdLmlkID09PSBlbFtjdHhdLmlkKSB7XG4gICAgICAgIG5vZGVMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBlbFtjdHhdO1xuICB9XG59O1xuIiwiLyogTW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGF5bG9yaGFrZXMvZmVjaGFcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgVGF5bG9yIEhha2VzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqICAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSovXG4vLyDmioogWVlZWS1NTS1ERCDmlLnmiJDkuoYgeXl5eS1NTS1kZFxuKGZ1bmN0aW9uIChtYWluKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogUGFyc2Ugb3IgZm9ybWF0IGRhdGVzXG4gICAqIEBjbGFzcyBmZWNoYVxuICAgKi9cbiAgdmFyIGZlY2hhID0ge307XG4gIHZhciB0b2tlbiA9IC9kezEsNH18TXsxLDR9fHl5KD86eXkpP3xTezEsM318RG98Wlp8KFtIaE1zRG1dKVxcMT98W2FBXXxcIlteXCJdKlwifCdbXiddKicvZztcbiAgdmFyIHR3b0RpZ2l0cyA9ICdcXFxcZFxcXFxkPyc7XG4gIHZhciB0aHJlZURpZ2l0cyA9ICdcXFxcZHszfSc7XG4gIHZhciBmb3VyRGlnaXRzID0gJ1xcXFxkezR9JztcbiAgdmFyIHdvcmQgPSAnW15cXFxcc10rJztcbiAgdmFyIGxpdGVyYWwgPSAvXFxbKFteXSo/KVxcXS9nbTtcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnZXhFc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvW3xcXFxceygpW14kKyo/Li1dL2csICdcXFxcJCYnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3J0ZW4oYXJyLCBzTGVuKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5ld0Fyci5wdXNoKGFycltpXS5zdWJzdHIoMCwgc0xlbikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gbW9udGhVcGRhdGUoYXJyTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgdiwgaTE4bikge1xuICAgICAgdmFyIGluZGV4ID0gaTE4blthcnJOYW1lXS5pbmRleE9mKHYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgZC5tb250aCA9IGluZGV4O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcbiAgICB2YWwgPSBTdHJpbmcodmFsKTtcbiAgICBsZW4gPSBsZW4gfHwgMjtcbiAgICB3aGlsZSAodmFsLmxlbmd0aCA8IGxlbikge1xuICAgICAgdmFsID0gJzAnICsgdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdmFyIGRheU5hbWVzID0gWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddO1xuICB2YXIgbW9udGhOYW1lcyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuICB2YXIgbW9udGhOYW1lc1Nob3J0ID0gc2hvcnRlbihtb250aE5hbWVzLCAzKTtcbiAgdmFyIGRheU5hbWVzU2hvcnQgPSBzaG9ydGVuKGRheU5hbWVzLCAzKTtcbiAgZmVjaGEuaTE4biA9IHtcbiAgICBkYXlOYW1lc1Nob3J0OiBkYXlOYW1lc1Nob3J0LFxuICAgIGRheU5hbWVzOiBkYXlOYW1lcyxcbiAgICBtb250aE5hbWVzU2hvcnQ6IG1vbnRoTmFtZXNTaG9ydCxcbiAgICBtb250aE5hbWVzOiBtb250aE5hbWVzLFxuICAgIGFtUG06IFsnYW0nLCAncG0nXSxcbiAgICBEb0ZuOiBmdW5jdGlvbiBEb0ZuKEQpIHtcbiAgICAgIHJldHVybiBEICsgWyd0aCcsICdzdCcsICduZCcsICdyZCddW0QgJSAxMCA+IDMgPyAwIDogKEQgLSBEICUgMTAgIT09IDEwKSAqIEQgJSAxMF07XG4gICAgfVxuICB9O1xuXG4gIHZhciBmb3JtYXRGbGFncyA9IHtcbiAgICBEOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXREYXkoKTtcbiAgICB9LFxuICAgIEREOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0RGF5KCkpO1xuICAgIH0sXG4gICAgRG86IGZ1bmN0aW9uKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBpMThuLkRvRm4oZGF0ZU9iai5nZXREYXRlKCkpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24oZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0RGF0ZSgpO1xuICAgIH0sXG4gICAgZGQ6IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXREYXRlKCkpO1xuICAgIH0sXG4gICAgZGRkOiBmdW5jdGlvbihkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5kYXlOYW1lc1Nob3J0W2RhdGVPYmouZ2V0RGF5KCldO1xuICAgIH0sXG4gICAgZGRkZDogZnVuY3Rpb24oZGF0ZU9iaiwgaTE4bikge1xuICAgICAgcmV0dXJuIGkxOG4uZGF5TmFtZXNbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBNOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXRNb250aCgpICsgMTtcbiAgICB9LFxuICAgIE1NOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0TW9udGgoKSArIDEpO1xuICAgIH0sXG4gICAgTU1NOiBmdW5jdGlvbihkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzU2hvcnRbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIE1NTU06IGZ1bmN0aW9uKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBpMThuLm1vbnRoTmFtZXNbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIHl5OiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKFN0cmluZyhkYXRlT2JqLmdldEZ1bGxZZWFyKCkpLCA0KS5zdWJzdHIoMik7XG4gICAgfSxcbiAgICB5eXl5OiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgNCk7XG4gICAgfSxcbiAgICBoOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXRIb3VycygpICUgMTIgfHwgMTI7XG4gICAgfSxcbiAgICBoaDogZnVuY3Rpb24oZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMik7XG4gICAgfSxcbiAgICBIOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXRIb3VycygpO1xuICAgIH0sXG4gICAgSEg6IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXRIb3VycygpKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldE1pbnV0ZXMoKTtcbiAgICB9LFxuICAgIG1tOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0TWludXRlcygpKTtcbiAgICB9LFxuICAgIHM6IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldFNlY29uZHMoKTtcbiAgICB9LFxuICAgIHNzOiBmdW5jdGlvbihkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0U2Vjb25kcygpKTtcbiAgICB9LFxuICAgIFM6IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGRhdGVPYmouZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMDApO1xuICAgIH0sXG4gICAgU1M6IGZ1bmN0aW9uKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoTWF0aC5yb3VuZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpIC8gMTApLCAyKTtcbiAgICB9LFxuICAgIFNTUzogZnVuY3Rpb24oZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldEhvdXJzKCkgPCAxMiA/IGkxOG4uYW1QbVswXSA6IGkxOG4uYW1QbVsxXTtcbiAgICB9LFxuICAgIEE6IGZ1bmN0aW9uKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldEhvdXJzKCkgPCAxMiA/IGkxOG4uYW1QbVswXS50b1VwcGVyQ2FzZSgpIDogaTE4bi5hbVBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBaWjogZnVuY3Rpb24oZGF0ZU9iaikge1xuICAgICAgdmFyIG8gPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICByZXR1cm4gKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwYXJzZUZsYWdzID0ge1xuICAgIGQ6IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLmRheSA9IHY7XG4gICAgfV0sXG4gICAgRG86IFt0d29EaWdpdHMgKyB3b3JkLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5kYXkgPSBwYXJzZUludCh2LCAxMCk7XG4gICAgfV0sXG4gICAgTTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubW9udGggPSB2IC0gMTtcbiAgICB9XSxcbiAgICB5eTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIHZhciBkYSA9IG5ldyBEYXRlKCksIGNlbnQgPSArKCcnICsgZGEuZ2V0RnVsbFllYXIoKSkuc3Vic3RyKDAsIDIpO1xuICAgICAgZC55ZWFyID0gJycgKyAodiA+IDY4ID8gY2VudCAtIDEgOiBjZW50KSArIHY7XG4gICAgfV0sXG4gICAgaDogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQuaG91ciA9IHY7XG4gICAgfV0sXG4gICAgbTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubWludXRlID0gdjtcbiAgICB9XSxcbiAgICBzOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5zZWNvbmQgPSB2O1xuICAgIH1dLFxuICAgIHl5eXk6IFtmb3VyRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC55ZWFyID0gdjtcbiAgICB9XSxcbiAgICBTOiBbJ1xcXFxkJywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubWlsbGlzZWNvbmQgPSB2ICogMTAwO1xuICAgIH1dLFxuICAgIFNTOiBbJ1xcXFxkezJ9JywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubWlsbGlzZWNvbmQgPSB2ICogMTA7XG4gICAgfV0sXG4gICAgU1NTOiBbdGhyZWVEaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLm1pbGxpc2Vjb25kID0gdjtcbiAgICB9XSxcbiAgICBEOiBbdHdvRGlnaXRzLCBub29wXSxcbiAgICBkZGQ6IFt3b3JkLCBub29wXSxcbiAgICBNTU06IFt3b3JkLCBtb250aFVwZGF0ZSgnbW9udGhOYW1lc1Nob3J0JyldLFxuICAgIE1NTU06IFt3b3JkLCBtb250aFVwZGF0ZSgnbW9udGhOYW1lcycpXSxcbiAgICBhOiBbd29yZCwgZnVuY3Rpb24gKGQsIHYsIGkxOG4pIHtcbiAgICAgIHZhciB2YWwgPSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodmFsID09PSBpMThuLmFtUG1bMF0pIHtcbiAgICAgICAgZC5pc1BtID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzFdKSB7XG4gICAgICAgIGQuaXNQbSA9IHRydWU7XG4gICAgICB9XG4gICAgfV0sXG4gICAgWlo6IFsnW15cXFxcc10qP1tcXFxcK1xcXFwtXVxcXFxkXFxcXGQ6P1xcXFxkXFxcXGR8W15cXFxcc10qP1onLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgdmFyIHBhcnRzID0gKHYgKyAnJykubWF0Y2goLyhbKy1dfFxcZFxcZCkvZ2kpLCBtaW51dGVzO1xuXG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICBkLnRpbWV6b25lT2Zmc2V0ID0gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICAgIH1cbiAgICB9XVxuICB9O1xuICBwYXJzZUZsYWdzLmRkID0gcGFyc2VGbGFncy5kO1xuICBwYXJzZUZsYWdzLmRkZGQgPSBwYXJzZUZsYWdzLmRkZDtcbiAgcGFyc2VGbGFncy5ERCA9IHBhcnNlRmxhZ3MuRDtcbiAgcGFyc2VGbGFncy5tbSA9IHBhcnNlRmxhZ3MubTtcbiAgcGFyc2VGbGFncy5oaCA9IHBhcnNlRmxhZ3MuSCA9IHBhcnNlRmxhZ3MuSEggPSBwYXJzZUZsYWdzLmg7XG4gIHBhcnNlRmxhZ3MuTU0gPSBwYXJzZUZsYWdzLk07XG4gIHBhcnNlRmxhZ3Muc3MgPSBwYXJzZUZsYWdzLnM7XG4gIHBhcnNlRmxhZ3MuQSA9IHBhcnNlRmxhZ3MuYTtcblxuXG4gIC8vIFNvbWUgY29tbW9uIGZvcm1hdCBzdHJpbmdzXG4gIGZlY2hhLm1hc2tzID0ge1xuICAgIGRlZmF1bHQ6ICdkZGQgTU1NIGRkIHl5eXkgSEg6bW06c3MnLFxuICAgIHNob3J0RGF0ZTogJ00vRC95eScsXG4gICAgbWVkaXVtRGF0ZTogJ01NTSBkLCB5eXl5JyxcbiAgICBsb25nRGF0ZTogJ01NTU0gZCwgeXl5eScsXG4gICAgZnVsbERhdGU6ICdkZGRkLCBNTU1NIGQsIHl5eXknLFxuICAgIHNob3J0VGltZTogJ0hIOm1tJyxcbiAgICBtZWRpdW1UaW1lOiAnSEg6bW06c3MnLFxuICAgIGxvbmdUaW1lOiAnSEg6bW06c3MuU1NTJ1xuICB9O1xuXG4gIC8qKipcbiAgICogRm9ybWF0IGEgZGF0ZVxuICAgKiBAbWV0aG9kIGZvcm1hdFxuICAgKiBAcGFyYW0ge0RhdGV8bnVtYmVyfSBkYXRlT2JqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXNrIEZvcm1hdCBvZiB0aGUgZGF0ZSwgaS5lLiAnbW0tZGQteXknIG9yICdzaG9ydERhdGUnXG4gICAqL1xuICBmZWNoYS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZU9iaiwgbWFzaywgaTE4blNldHRpbmdzKSB7XG4gICAgdmFyIGkxOG4gPSBpMThuU2V0dGluZ3MgfHwgZmVjaGEuaTE4bjtcblxuICAgIGlmICh0eXBlb2YgZGF0ZU9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGRhdGVPYmogPSBuZXcgRGF0ZShkYXRlT2JqKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGVPYmopICE9PSAnW29iamVjdCBEYXRlXScgfHwgaXNOYU4oZGF0ZU9iai5nZXRUaW1lKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRGF0ZSBpbiBmZWNoYS5mb3JtYXQnKTtcbiAgICB9XG5cbiAgICBtYXNrID0gZmVjaGEubWFza3NbbWFza10gfHwgbWFzayB8fCBmZWNoYS5tYXNrc1snZGVmYXVsdCddO1xuXG4gICAgdmFyIGxpdGVyYWxzID0gW107XG5cbiAgICAvLyBNYWtlIGxpdGVyYWxzIGluYWN0aXZlIGJ5IHJlcGxhY2luZyB0aGVtIHdpdGggPz9cbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKGxpdGVyYWwsIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgbGl0ZXJhbHMucHVzaCgkMSk7XG4gICAgICByZXR1cm4gJ0BAQCc7XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgZm9ybWF0dGluZyBydWxlc1xuICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICQwIGluIGZvcm1hdEZsYWdzID8gZm9ybWF0RmxhZ3NbJDBdKGRhdGVPYmosIGkxOG4pIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSk7XG4gICAgfSk7XG4gICAgLy8gSW5saW5lIGxpdGVyYWwgdmFsdWVzIGJhY2sgaW50byB0aGUgZm9ybWF0dGVkIHZhbHVlXG4gICAgcmV0dXJuIG1hc2sucmVwbGFjZSgvQEBAL2csIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpdGVyYWxzLnNoaWZ0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgZGF0ZSBzdHJpbmcgaW50byBhbiBvYmplY3QsIGNoYW5nZXMgLSBpbnRvIC9cbiAgICogQG1ldGhvZCBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVN0ciBEYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IERhdGUgcGFyc2UgZm9ybWF0XG4gICAqIEByZXR1cm5zIHtEYXRlfGJvb2xlYW59XG4gICAqL1xuICBmZWNoYS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRlU3RyLCBmb3JtYXQsIGkxOG5TZXR0aW5ncykge1xuICAgIHZhciBpMThuID0gaTE4blNldHRpbmdzIHx8IGZlY2hhLmkxOG47XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQgaW4gZmVjaGEucGFyc2UnKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmZWNoYS5tYXNrc1tmb3JtYXRdIHx8IGZvcm1hdDtcblxuICAgIC8vIEF2b2lkIHJlZ3VsYXIgZXhwcmVzc2lvbiBkZW5pYWwgb2Ygc2VydmljZSwgZmFpbCBlYXJseSBmb3IgcmVhbGx5IGxvbmcgc3RyaW5nc1xuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvUmVndWxhcl9leHByZXNzaW9uX0RlbmlhbF9vZl9TZXJ2aWNlXy1fUmVEb1NcbiAgICBpZiAoZGF0ZVN0ci5sZW5ndGggPiAxMDAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZUluZm8gPSB7fTtcbiAgICB2YXIgcGFyc2VJbmZvID0gW107XG4gICAgdmFyIGxpdGVyYWxzID0gW107XG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobGl0ZXJhbCwgZnVuY3Rpb24oJDAsICQxKSB7XG4gICAgICBsaXRlcmFscy5wdXNoKCQxKTtcbiAgICAgIHJldHVybiAnQEBAJztcbiAgICB9KTtcbiAgICB2YXIgbmV3Rm9ybWF0ID0gcmVnZXhFc2NhcGUoZm9ybWF0KS5yZXBsYWNlKHRva2VuLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgIGlmIChwYXJzZUZsYWdzWyQwXSkge1xuICAgICAgICB2YXIgaW5mbyA9IHBhcnNlRmxhZ3NbJDBdO1xuICAgICAgICBwYXJzZUluZm8ucHVzaChpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuICcoJyArIGluZm9bMF0gKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkMDtcbiAgICB9KTtcbiAgICBuZXdGb3JtYXQgPSBuZXdGb3JtYXQucmVwbGFjZSgvQEBAL2csIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpdGVyYWxzLnNoaWZ0KCk7XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBkYXRlU3RyLm1hdGNoKG5ldyBSZWdFeHAobmV3Rm9ybWF0LCAnaScpKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VJbmZvW2kgLSAxXShkYXRlSW5mbywgbWF0Y2hlc1tpXSwgaTE4bik7XG4gICAgfVxuXG4gICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBpZiAoZGF0ZUluZm8uaXNQbSA9PT0gdHJ1ZSAmJiBkYXRlSW5mby5ob3VyICE9IG51bGwgJiYgK2RhdGVJbmZvLmhvdXIgIT09IDEyKSB7XG4gICAgICBkYXRlSW5mby5ob3VyID0gK2RhdGVJbmZvLmhvdXIgKyAxMjtcbiAgICB9IGVsc2UgaWYgKGRhdGVJbmZvLmlzUG0gPT09IGZhbHNlICYmICtkYXRlSW5mby5ob3VyID09PSAxMikge1xuICAgICAgZGF0ZUluZm8uaG91ciA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRhdGU7XG4gICAgaWYgKGRhdGVJbmZvLnRpbWV6b25lT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIGRhdGVJbmZvLm1pbnV0ZSA9ICsoZGF0ZUluZm8ubWludXRlIHx8IDApIC0gK2RhdGVJbmZvLnRpbWV6b25lT2Zmc2V0O1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGVJbmZvLnllYXIgfHwgdG9kYXkuZ2V0RnVsbFllYXIoKSwgZGF0ZUluZm8ubW9udGggfHwgMCwgZGF0ZUluZm8uZGF5IHx8IDEsXG4gICAgICAgIGRhdGVJbmZvLmhvdXIgfHwgMCwgZGF0ZUluZm8ubWludXRlIHx8IDAsIGRhdGVJbmZvLnNlY29uZCB8fCAwLCBkYXRlSW5mby5taWxsaXNlY29uZCB8fCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlSW5mby55ZWFyIHx8IHRvZGF5LmdldEZ1bGxZZWFyKCksIGRhdGVJbmZvLm1vbnRoIHx8IDAsIGRhdGVJbmZvLmRheSB8fCAxLFxuICAgICAgICBkYXRlSW5mby5ob3VyIHx8IDAsIGRhdGVJbmZvLm1pbnV0ZSB8fCAwLCBkYXRlSW5mby5zZWNvbmQgfHwgMCwgZGF0ZUluZm8ubWlsbGlzZWNvbmQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmVjaGE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmZWNoYTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYWluLmZlY2hhID0gZmVjaGE7XG4gIH1cbn0pKHRoaXMpO1xuIiwiLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuXG5jb25zdCBpc1NlcnZlciA9IFZ1ZS5wcm90b3R5cGUuJGlzU2VydmVyO1xuY29uc3QgU1BFQ0lBTF9DSEFSU19SRUdFWFAgPSAvKFtcXDpcXC1cXF9dKyguKSkvZztcbmNvbnN0IE1PWl9IQUNLX1JFR0VYUCA9IC9ebW96KFtBLVpdKS87XG5jb25zdCBpZVZlcnNpb24gPSBpc1NlcnZlciA/IDAgOiBOdW1iZXIoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHRyaW0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIChzdHJpbmcgfHwgJycpLnJlcGxhY2UoL15bXFxzXFx1RkVGRl0rfFtcXHNcXHVGRUZGXSskL2csICcnKTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY2FtZWxDYXNlID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKFNQRUNJQUxfQ0hBUlNfUkVHRVhQLCBmdW5jdGlvbihfLCBzZXBhcmF0b3IsIGxldHRlciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA/IGxldHRlci50b1VwcGVyQ2FzZSgpIDogbGV0dGVyO1xuICB9KS5yZXBsYWNlKE1PWl9IQUNLX1JFR0VYUCwgJ01veiQxJyk7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9uID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoIWlzU2VydmVyICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50ICYmIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50ICYmIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKCk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgb2ZmID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoIWlzU2VydmVyICYmIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoZWxlbWVudCAmJiBldmVudCkge1xuICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSkoKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBvbmNlID0gZnVuY3Rpb24oZWwsIGV2ZW50LCBmbikge1xuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9mZihlbCwgZXZlbnQsIGxpc3RlbmVyKTtcbiAgfTtcbiAgb24oZWwsIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKCFlbCB8fCAhY2xzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjbHMuaW5kZXhPZignICcpICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdjbGFzc05hbWUgc2hvdWxkIG5vdCBjb250YWluIHNwYWNlLicpO1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNscyArICcgJykgPiAtMTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgdmFyIGN1ckNsYXNzID0gZWwuY2xhc3NOYW1lO1xuICB2YXIgY2xhc3NlcyA9IChjbHMgfHwgJycpLnNwbGl0KCcgJyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBjbHNOYW1lID0gY2xhc3Nlc1tpXTtcbiAgICBpZiAoIWNsc05hbWUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHNOYW1lKTtcbiAgICB9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgY2xzTmFtZSkpIHtcbiAgICAgIGN1ckNsYXNzICs9ICcgJyArIGNsc05hbWU7XG4gICAgfVxuICB9XG4gIGlmICghZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ckNsYXNzKTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gIGlmICghZWwgfHwgIWNscykgcmV0dXJuO1xuICB2YXIgY2xhc3NlcyA9IGNscy5zcGxpdCgnICcpO1xuICB2YXIgY3VyQ2xhc3MgPSAnICcgKyBlbC5jbGFzc05hbWUgKyAnICc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBjbHNOYW1lID0gY2xhc3Nlc1tpXTtcbiAgICBpZiAoIWNsc05hbWUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHNOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NsYXNzKGVsLCBjbHNOYW1lKSkge1xuICAgICAgY3VyQ2xhc3MgPSBjdXJDbGFzcy5yZXBsYWNlKCcgJyArIGNsc05hbWUgKyAnICcsICcgJyk7XG4gICAgfVxuICB9XG4gIGlmICghZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRyaW0oY3VyQ2xhc3MpKTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRTdHlsZSA9IGllVmVyc2lvbiA8IDkgPyBmdW5jdGlvbihlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG4gIGlmICghZWxlbWVudCB8fCAhc3R5bGVOYW1lKSByZXR1cm4gbnVsbDtcbiAgc3R5bGVOYW1lID0gY2FtZWxDYXNlKHN0eWxlTmFtZSk7XG4gIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICBzdHlsZU5hbWUgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbiAgdHJ5IHtcbiAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xuICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZmlsdGVycy5pdGVtKCdhbHBoYScpLm9wYWNpdHkgLyAxMDA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSB8fCBlbGVtZW50LmN1cnJlbnRTdHlsZSA/IGVsZW1lbnQuY3VycmVudFN0eWxlW3N0eWxlTmFtZV0gOiBudWxsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICB9XG59IDogZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVOYW1lKSB7XG4gIGlmIChpc1NlcnZlcikgcmV0dXJuO1xuICBpZiAoIWVsZW1lbnQgfHwgIXN0eWxlTmFtZSkgcmV0dXJuIG51bGw7XG4gIHN0eWxlTmFtZSA9IGNhbWVsQ2FzZShzdHlsZU5hbWUpO1xuICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgfVxuICB0cnkge1xuICAgIHZhciBjb21wdXRlZCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpO1xuICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gfHwgY29tcHV0ZWQgPyBjb21wdXRlZFtzdHlsZU5hbWVdIDogbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV07XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICBpZiAoIWVsZW1lbnQgfHwgIXN0eWxlTmFtZSkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVOYW1lKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlTmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0eWxlTmFtZSA9IGNhbWVsQ2FzZShzdHlsZU5hbWUpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdvcGFjaXR5JyAmJiBpZVZlcnNpb24gPCA5KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9IGlzTmFOKHZhbHVlKSA/ICcnIDogJ2FscGhhKG9wYWNpdHk9JyArIHZhbHVlICogMTAwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc1Njcm9sbCA9IChlbCwgdmVydGljYWwpID0+IHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG5cbiAgY29uc3QgZGV0ZXJtaW5lZERpcmVjdGlvbiA9IHZlcnRpY2FsICE9PSBudWxsICYmIHZlcnRpY2FsICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IG92ZXJmbG93ID0gZGV0ZXJtaW5lZERpcmVjdGlvblxuICAgID8gdmVydGljYWxcbiAgICAgID8gZ2V0U3R5bGUoZWwsICdvdmVyZmxvdy15JylcbiAgICAgIDogZ2V0U3R5bGUoZWwsICdvdmVyZmxvdy14JylcbiAgICA6IGdldFN0eWxlKGVsLCAnb3ZlcmZsb3cnKTtcblxuICByZXR1cm4gb3ZlcmZsb3cubWF0Y2goLyhzY3JvbGx8YXV0b3xvdmVybGF5KS8pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNjcm9sbENvbnRhaW5lciA9IChlbCwgdmVydGljYWwpID0+IHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG5cbiAgbGV0IHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKFt3aW5kb3csIGRvY3VtZW50LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdLmluY2x1ZGVzKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGlmIChpc1Njcm9sbChwYXJlbnQsIHZlcnRpY2FsKSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gcGFyZW50O1xufTtcblxuZXhwb3J0IGNvbnN0IGlzSW5Db250YWluZXIgPSAoZWwsIGNvbnRhaW5lcikgPT4ge1xuICBpZiAoaXNTZXJ2ZXIgfHwgIWVsIHx8ICFjb250YWluZXIpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IGNvbnRhaW5lclJlY3Q7XG5cbiAgaWYgKFt3aW5kb3csIGRvY3VtZW50LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG51bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMoY29udGFpbmVyKSkge1xuICAgIGNvbnRhaW5lclJlY3QgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICByZXR1cm4gZWxSZWN0LnRvcCA8IGNvbnRhaW5lclJlY3QuYm90dG9tICYmXG4gICAgZWxSZWN0LmJvdHRvbSA+IGNvbnRhaW5lclJlY3QudG9wICYmXG4gICAgZWxSZWN0LnJpZ2h0ID4gY29udGFpbmVyUmVjdC5sZWZ0ICYmXG4gICAgZWxSZWN0LmxlZnQgPCBjb250YWluZXJSZWN0LnJpZ2h0O1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRhcmdldCkge1xuICBmb3IgKGxldCBpID0gMSwgaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzW2ldIHx8IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiB7e3ZlcnNpb259fVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuLy9cbi8vIENyb3NzIG1vZHVsZSBsb2FkZXJcbi8vIFN1cHBvcnRlZDogTm9kZSwgQU1ELCBCcm93c2VyIGdsb2JhbHNcbi8vXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LlBvcHBlciA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciByb290ID0gd2luZG93O1xuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIERFRkFVTFRTID0ge1xuICAgICAgICAvLyBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlclxuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gICAgICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcblxuICAgICAgICAvLyBzaGlmdCBwb3BwZXIgZnJvbSBpdHMgb3JpZ2luIGJ5IHRoZSBnaXZlbiBhbW91bnQgb2YgcGl4ZWxzIChjYW4gYmUgbmVnYXRpdmUpXG4gICAgICAgIG9mZnNldDogMCxcblxuICAgICAgICAvLyB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGFjdCBhcyBib3VuZGFyeSBvZiB0aGUgcG9wcGVyXG4gICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuXG4gICAgICAgIC8vIGFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllcyBhbmQgdGhlIHBvcHBlclxuICAgICAgICBib3VuZGFyaWVzUGFkZGluZzogNSxcblxuICAgICAgICAvLyBwb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhpcyBvcmRlcixcbiAgICAgICAgLy8gYnkgZGVmYXVsdCwgdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYm91bmRhcmllc0VsZW1lbnRcbiAgICAgICAgcHJldmVudE92ZXJmbG93T3JkZXI6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG5cbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIHVzZWQgYnkgZmxpcCB0byBjaGFuZ2UgdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyXG4gICAgICAgIGZsaXBCZWhhdmlvcjogJ2ZsaXAnLFxuXG4gICAgICAgIGFycm93RWxlbWVudDogJ1t4LWFycm93XScsXG5cbiAgICAgICAgYXJyb3dPZmZzZXQ6IDAsXG5cbiAgICAgICAgLy8gbGlzdCBvZiBmdW5jdGlvbnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICAgICAgICBtb2RpZmllcnM6IFsgJ3NoaWZ0JywgJ29mZnNldCcsICdwcmV2ZW50T3ZlcmZsb3cnLCAna2VlcFRvZ2V0aGVyJywgJ2Fycm93JywgJ2ZsaXAnLCAnYXBwbHlTdHlsZSddLFxuXG4gICAgICAgIG1vZGlmaWVyc0lnbm9yZWQ6IFtdLFxuXG4gICAgICAgIGZvcmNlQWJzb2x1dGU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3IgUG9wcGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8T2JqZWN0fSBwb3BwZXJcbiAgICAgKiAgICAgIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIsIG9yIGEgY29uZmlndXJhdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBwb3BwZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwb3BwZXIudGFnTmFtZT0nZGl2J10gVGhlIHRhZyBuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgcG9wcGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb3BwZXIuY2xhc3NOYW1lcz1bJ3BvcHBlciddXSBBcnJheSBvZiBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBnZW5lcmF0ZWQgcG9wcGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb3BwZXIuYXR0cmlidXRlc10gQXJyYXkgb2YgYXR0cmlidXRlcyB0byBhcHBseSwgc3BlY2lmeSBgYXR0cjp2YWx1ZWAgdG8gYXNzaWduIGEgdmFsdWUgdG8gaXQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtwb3BwZXIucGFyZW50PXdpbmRvdy5kb2N1bWVudC5ib2R5XSBUaGUgcGFyZW50IGVsZW1lbnQsIGdpdmVuIGFzIEhUTUxFbGVtZW50IG9yIGFzIHF1ZXJ5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BvcHBlci5jb250ZW50PScnXSBUaGUgY29udGVudCBvZiB0aGUgcG9wcGVyLCBpdCBjYW4gYmUgdGV4dCwgaHRtbCwgb3Igbm9kZTsgaWYgaXQgaXMgbm90IHRleHQsIHNldCBgY29udGVudFR5cGVgIHRvIGBodG1sYCBvciBgbm9kZWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwb3BwZXIuY29udGVudFR5cGU9J3RleHQnXSBJZiBgaHRtbGAsIHRoZSBgY29udGVudGAgd2lsbCBiZSBwYXJzZWQgYXMgSFRNTC4gSWYgYG5vZGVgLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFzLWlzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcG9wcGVyLmFycm93VGFnTmFtZT0nZGl2J10gU2FtZSBhcyBgcG9wcGVyLnRhZ05hbWVgIGJ1dCBmb3IgdGhlIGFycm93IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvcHBlci5hcnJvd0NsYXNzTmFtZXM9J3BvcHBlcl9fYXJyb3cnXSBTYW1lIGFzIGBwb3BwZXIuY2xhc3NOYW1lc2AgYnV0IGZvciB0aGUgYXJyb3cgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BvcHBlci5hcnJvd0F0dHJpYnV0ZXM9Wyd4LWFycm93J11dIFNhbWUgYXMgYHBvcHBlci5hdHRyaWJ1dGVzYCBidXQgZm9yIHRoZSBhcnJvdyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBsYWNlbWVudD1ib3R0b21dXG4gICAgICogICAgICBQbGFjZW1lbnQgb2YgdGhlIHBvcHBlciBhY2NlcHRlZCB2YWx1ZXM6IGB0b3AoLXN0YXJ0LCAtZW5kKSwgcmlnaHQoLXN0YXJ0LCAtZW5kKSwgYm90dG9tKC1zdGFydCwgLXJpZ2h0KSxcbiAgICAgKiAgICAgIGxlZnQoLXN0YXJ0LCAtZW5kKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBbb3B0aW9ucy5hcnJvd0VsZW1lbnQ9J1t4LWFycm93XSddXG4gICAgICogICAgICBUaGUgRE9NIE5vZGUgdXNlZCBhcyBhcnJvdyBmb3IgdGhlIHBvcHBlciwgb3IgYSBDU1Mgc2VsZWN0b3IgdXNlZCB0byBnZXQgdGhlIERPTSBub2RlLiBJdCBtdXN0IGJlIGNoaWxkIG9mXG4gICAgICogICAgICBpdHMgcGFyZW50IFBvcHBlci4gUG9wcGVyLmpzIHdpbGwgYXBwbHkgdG8gdGhlIGdpdmVuIGVsZW1lbnQgdGhlIHN0eWxlIHJlcXVpcmVkIHRvIGFsaWduIHRoZSBhcnJvdyB3aXRoIGl0c1xuICAgICAqICAgICAgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICogICAgICBCeSBkZWZhdWx0LCBpdCB3aWxsIGxvb2sgZm9yIGEgY2hpbGQgbm9kZSBvZiB0aGUgcG9wcGVyIHdpdGggdGhlIGB4LWFycm93YCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdwdUFjY2VsZXJhdGlvbj10cnVlXVxuICAgICAqICAgICAgV2hlbiB0aGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlLCB0aGUgcG9wcGVyIHBvc2l0aW9uIHdpbGwgYmUgYXBwbGllZCB1c2luZyBDU1MzIHRyYW5zbGF0ZTNkLCBhbGxvd2luZyB0aGVcbiAgICAgKiAgICAgIGJyb3dzZXIgdG8gdXNlIHRoZSBHUFUgdG8gYWNjZWxlcmF0ZSB0aGUgcmVuZGVyaW5nLlxuICAgICAqICAgICAgSWYgc2V0IHRvIGZhbHNlLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIHVzaW5nIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcywgbm90IHVzaW5nIHRoZSBHUFUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTBdXG4gICAgICogICAgICBBbW91bnQgb2YgcGl4ZWxzIHRoZSBwb3BwZXIgd2lsbCBiZSBzaGlmdGVkIChjYW4gYmUgbmVnYXRpdmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gW29wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J11cbiAgICAgKiAgICAgIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24sIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZVxuICAgICAqICAgICAgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllcyAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYm91bmRhcmllc1BhZGRpbmc9NV1cbiAgICAgKiAgICAgIEFkZGl0aW9uYWwgcGFkZGluZyBmb3IgdGhlIGJvdW5kYXJpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnByZXZlbnRPdmVyZmxvd09yZGVyPVsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ11dXG4gICAgICogICAgICBPcmRlciB1c2VkIHdoZW4gUG9wcGVyLmpzIHRyaWVzIHRvIGF2b2lkIG92ZXJmbG93cyBmcm9tIHRoZSBib3VuZGFyaWVzLCB0aGV5IHdpbGwgYmUgY2hlY2tlZCBpbiBvcmRlcixcbiAgICAgKiAgICAgIHRoaXMgbWVhbnMgdGhhdCB0aGUgbGFzdCBvbmVzIHdpbGwgbmV2ZXIgb3ZlcmZsb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbb3B0aW9ucy5mbGlwQmVoYXZpb3I9J2ZsaXAnXVxuICAgICAqICAgICAgVGhlIGJlaGF2aW9yIHVzZWQgYnkgdGhlIGBmbGlwYCBtb2RpZmllciB0byBjaGFuZ2UgdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyIHdoZW4gdGhlIGxhdHRlciBpcyB0cnlpbmcgdG9cbiAgICAgKiAgICAgIG92ZXJsYXAgaXRzIHJlZmVyZW5jZSBlbGVtZW50LiBEZWZpbmluZyBgZmxpcGAgYXMgdmFsdWUsIHRoZSBwbGFjZW1lbnQgd2lsbCBiZSBmbGlwcGVkIG9uXG4gICAgICogICAgICBpdHMgYXhpcyAoYHJpZ2h0IC0gbGVmdGAsIGB0b3AgLSBib3R0b21gKS5cbiAgICAgKiAgICAgIFlvdSBjYW4gZXZlbiBwYXNzIGFuIGFycmF5IG9mIHBsYWNlbWVudHMgKGVnOiBgWydyaWdodCcsICdsZWZ0JywgJ3RvcCddYCApIHRvIG1hbnVhbGx5IHNwZWNpZnlcbiAgICAgKiAgICAgIGhvdyBhbHRlciB0aGUgcGxhY2VtZW50IHdoZW4gYSBmbGlwIGlzIG5lZWRlZC4gKGVnLiBpbiB0aGUgYWJvdmUgZXhhbXBsZSwgaXQgd291bGQgZmlyc3QgZmxpcCBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICogICAgICB0aGVuLCBpZiBldmVuIGluIGl0cyBuZXcgcGxhY2VtZW50LCB0aGUgcG9wcGVyIGlzIG92ZXJsYXBwaW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudCwgaXQgd2lsbCBiZSBtb3ZlZCB0byB0b3ApXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tb2RpZmllcnM9WyAnc2hpZnQnLCAnb2Zmc2V0JywgJ3ByZXZlbnRPdmVyZmxvdycsICdrZWVwVG9nZXRoZXInLCAnYXJyb3cnLCAnZmxpcCcsICdhcHBseVN0eWxlJ11dXG4gICAgICogICAgICBMaXN0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIG1vZGlmeSB0aGUgZGF0YSBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLCBhZGQgeW91ciBjdXN0b20gZnVuY3Rpb25zXG4gICAgICogICAgICB0byB0aGlzIGFycmF5IHRvIGVkaXQgdGhlIG9mZnNldHMgYW5kIHBsYWNlbWVudC5cbiAgICAgKiAgICAgIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVmbGVjdCB0aGUgQHBhcmFtcyBhbmQgQHJldHVybnMgb2YgcHJldmVudE92ZXJmbG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tb2RpZmllcnNJZ25vcmVkPVtdXVxuICAgICAqICAgICAgUHV0IGhlcmUgYW55IGJ1aWx0LWluIG1vZGlmaWVyIG5hbWUgeW91IHdhbnQgdG8gZXhjbHVkZSBmcm9tIHRoZSBtb2RpZmllcnMgbGlzdFxuICAgICAqICAgICAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZWZsZWN0IHRoZSBAcGFyYW1zIGFuZCBAcmV0dXJucyBvZiBwcmV2ZW50T3ZlcmZsb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVtb3ZlT25EZXN0cm95PWZhbHNlXVxuICAgICAqICAgICAgU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2UgPSByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAgICAgLy8gaWYgdGhlIHBvcHBlciB2YXJpYWJsZSBpcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBwYXJzZSBpdCB0byBnZW5lcmF0ZSBhbiBIVE1MRWxlbWVudFxuICAgICAgICAvLyBnZW5lcmF0ZSBhIGRlZmF1bHQgcG9wcGVyIGlmIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgIHZhciBpc05vdERlZmluZWQgPSB0eXBlb2YgcG9wcGVyID09PSAndW5kZWZpbmVkJyB8fCBwb3BwZXIgPT09IG51bGw7XG4gICAgICAgIHZhciBpc0NvbmZpZyA9IHBvcHBlciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocG9wcGVyKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICAgIGlmIChpc05vdERlZmluZWQgfHwgaXNDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMucGFyc2UoaXNDb25maWcgPyBwb3BwZXIgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB1c2UgdGhlIGdpdmVuIEhUTUxFbGVtZW50IGFzIHBvcHBlclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHBlciA9IHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgICAgICAvLyByZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3RcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5tb2RpZmllcnMgPSB0aGlzLl9vcHRpb25zLm1vZGlmaWVycy5tYXAoZnVuY3Rpb24obW9kaWZpZXIpe1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGlnbm9yZWQgbW9kaWZpZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5tb2RpZmllcnNJZ25vcmVkLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZCB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyXG4gICAgICAgICAgICAvLyBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZSBjb3JyZWN0IHBvcHBlciBvZmZzZXRzXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgPT09ICdhcHBseVN0eWxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gcHJlZGVmaW5lZCBtb2RpZmllciBpZGVudGlmaWVkIGJ5IHN0cmluZyBvciBrZWVwIHRoZSBjdXN0b20gb25lXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RpZmllcnNbbW9kaWZpZXJdIHx8IG1vZGlmaWVyO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBhcHBseSB0aGUgcG9wcGVyIHBvc2l0aW9uIGJlZm9yZSBhbnkgY29tcHV0YXRpb25cbiAgICAgICAgdGhpcy5zdGF0ZS5wb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKHRoaXMuX3BvcHBlciwgdGhpcy5fcmVmZXJlbmNlKTtcbiAgICAgICAgc2V0U3R5bGUodGhpcy5fcG9wcGVyLCB7IHBvc2l0aW9uOiB0aGlzLnN0YXRlLnBvc2l0aW9uLCB0b3A6IDAgfSk7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgICB0aGlzLl9zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyBNZXRob2RzXG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgdGhpcy5fcG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BwZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nIHRoZSBuZXcgc3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0geyBpbnN0YW5jZTogdGhpcywgc3R5bGVzOiB7fSB9O1xuXG4gICAgICAgIC8vIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LCBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gICAgICAgIC8vIGFuZCByZWZlciB0byBfb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgZGF0YS5wbGFjZW1lbnQgPSB0aGlzLl9vcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgZGF0YS5fb3JpZ2luYWxQbGFjZW1lbnQgPSB0aGlzLl9vcHRpb25zLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgYW5kIHJlZmVyZW5jZSBvZmZzZXRzIGFuZCBwdXQgdGhlbSBpbnNpZGUgZGF0YS5vZmZzZXRzXG4gICAgICAgIGRhdGEub2Zmc2V0cyA9IHRoaXMuX2dldE9mZnNldHModGhpcy5fcG9wcGVyLCB0aGlzLl9yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICAgICAgICAvLyBnZXQgYm91bmRhcmllc1xuICAgICAgICBkYXRhLmJvdW5kYXJpZXMgPSB0aGlzLl9nZXRCb3VuZGFyaWVzKGRhdGEsIHRoaXMuX29wdGlvbnMuYm91bmRhcmllc1BhZGRpbmcsIHRoaXMuX29wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gICAgICAgIGRhdGEgPSB0aGlzLnJ1bk1vZGlmaWVycyhkYXRhLCB0aGlzLl9vcHRpb25zLm1vZGlmaWVycyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXRlLnVwZGF0ZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBpbml0aWFsaXphdGlvbiBvZiBwb3BwZXIgd2l0aCBhcyBmaXJzdCBhcmd1bWVudCB0aGUgUG9wcGVyIGluc3RhbmNlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLm9uQ3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgLy8gdGhlIGNyZWF0ZUNhbGxiYWNrcyByZXR1cm4gYXMgZmlyc3QgYXJndW1lbnQgdGhlIHBvcHBlciBpbnN0YW5jZVxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGVhY2ggdXBkYXRlIG9mIHBvcHBlciB3aXRoIGFzIGZpcnN0IGFyZ3VtZW50IHRoZSBzZXQgb2YgY29vcmRpbmF0ZXMgYW5kIGluZm9ybWF0aW9uc1xuICAgICAqIHVzZWQgdG8gc3R5bGUgcG9wcGVyIGFuZCBpdHMgYXJyb3cuXG4gICAgICogTk9URTogaXQgZG9lc24ndCBnZXQgZmlyZWQgb24gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGBQb3BwZXIudXBkYXRlKClgIG1ldGhvZCBpbnNpZGUgdGhlIGBQb3BwZXJgIGNvbnN0cnVjdG9yIVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHVzZWQgdG8gZ2VuZXJhdGUgcG9wcGVycyBmcm9tIGEgY29uZmlndXJhdGlvbiBmaWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IFsgJ3BvcHBlcicgXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgICAgcGFyZW50OiByb290LmRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICBhcnJvd1RhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgYXJyb3dDbGFzc05hbWVzOiBbICdwb3BwZXJfX2Fycm93JyBdLFxuICAgICAgICAgICAgYXJyb3dBdHRyaWJ1dGVzOiBbICd4LWFycm93J11cbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgY29uZmlnKTtcblxuICAgICAgICB2YXIgZCA9IHJvb3QuZG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIHBvcHBlciA9IGQuY3JlYXRlRWxlbWVudChjb25maWcudGFnTmFtZSk7XG4gICAgICAgIGFkZENsYXNzTmFtZXMocG9wcGVyLCBjb25maWcuY2xhc3NOYW1lcyk7XG4gICAgICAgIGFkZEF0dHJpYnV0ZXMocG9wcGVyLCBjb25maWcuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChjb25maWcuY29udGVudFR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgICAgcG9wcGVyLmFwcGVuZENoaWxkKGNvbmZpZy5jb250ZW50LmpxdWVyeSA/IGNvbmZpZy5jb250ZW50WzBdIDogY29uZmlnLmNvbnRlbnQpO1xuICAgICAgICB9ZWxzZSBpZiAoY29uZmlnLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgIHBvcHBlci5pbm5lckhUTUwgPSBjb25maWcuY29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcHBlci50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hcnJvd1RhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGQuY3JlYXRlRWxlbWVudChjb25maWcuYXJyb3dUYWdOYW1lKTtcbiAgICAgICAgICAgIGFkZENsYXNzTmFtZXMoYXJyb3csIGNvbmZpZy5hcnJvd0NsYXNzTmFtZXMpO1xuICAgICAgICAgICAgYWRkQXR0cmlidXRlcyhhcnJvdywgY29uZmlnLmFycm93QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBwb3BwZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGNvbmZpZy5wYXJlbnQuanF1ZXJ5ID8gY29uZmlnLnBhcmVudFswXSA6IGNvbmZpZy5wYXJlbnQ7XG5cbiAgICAgICAgLy8gaWYgdGhlIGdpdmVuIHBhcmVudCBpcyBhIHN0cmluZywgdXNlIGl0IHRvIG1hdGNoIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGlzIG1hdGNoZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSB1c2VkIGFzIHBhcmVudFxuICAgICAgICAvLyBpZiBubyBlbGVtZW50cyBhcmUgbWF0Y2hlZCwgdGhlIHNjcmlwdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50ID0gZC5xdWVyeVNlbGVjdG9yQWxsKGNvbmZpZy5wYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiB0aGUgZ2l2ZW4gYHBhcmVudGAgcXVlcnkoJyArIGNvbmZpZy5wYXJlbnQgKyAnKSBtYXRjaGVkIG1vcmUgdGhhbiBvbmUgZWxlbWVudCwgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0VSUk9SOiB0aGUgZ2l2ZW4gYHBhcmVudGAgZG9lc25cXCd0IGV4aXN0cyEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBnaXZlbiBwYXJlbnQgaXMgYSBET00gbm9kZXMgbGlzdCBvciBhbiBhcnJheSBvZiBub2RlcyB3aXRoIG1vcmUgdGhhbiBvbmUgZWxlbWVudCxcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQgYXMgcGFyZW50XG4gICAgICAgIGlmIChwYXJlbnQubGVuZ3RoID4gMSAmJiBwYXJlbnQgaW5zdGFuY2VvZiBFbGVtZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiB5b3UgaGF2ZSBwYXNzZWQgYXMgcGFyZW50IGEgbGlzdCBvZiBlbGVtZW50cywgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQnKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgZ2VuZXJhdGVkIHBvcHBlciB0byBpdHMgcGFyZW50XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwb3BwZXIpO1xuXG4gICAgICAgIHJldHVybiBwb3BwZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgY2xhc3MgbmFtZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFkZENsYXNzTmFtZXMoZWxlbWVudCwgY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFkZEF0dHJpYnV0ZXMoZWxlbWVudCwgWyAnZGF0YS1pbmZvOmZvb2JhcicgXSk7XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhZGRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUuc3BsaXQoJzonKVswXSwgYXR0cmlidXRlLnNwbGl0KCc6JylbMV0gfHwgJycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHtIVE1MRWxlbWVudH0gcG9wcGVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwb3NpdGlvblxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGdldE9mZnNldFBhcmVudChyZWZlcmVuY2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcmNlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaWRlIGlmIHRoZSBwb3BwZXIgd2lsbCBiZSBmaXhlZFxuICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgaW5zaWRlIGEgZml4ZWQgY29udGV4dCwgdGhlIHBvcHBlciB3aWxsIGJlIGZpeGVkIGFzIHdlbGwgdG8gYWxsb3cgdGhlbSB0byBzY3JvbGwgdG9nZXRoZXJcbiAgICAgICAgdmFyIGlzUGFyZW50Rml4ZWQgPSBpc0ZpeGVkKHJlZmVyZW5jZSwgY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGlzUGFyZW50Rml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLl9nZXRPZmZzZXRzID0gZnVuY3Rpb24ocG9wcGVyLCByZWZlcmVuY2UsIHBsYWNlbWVudCkge1xuICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgdmFyIHBvcHBlck9mZnNldHMgPSB7fTtcblxuICAgICAgICBwb3BwZXJPZmZzZXRzLnBvc2l0aW9uID0gdGhpcy5zdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGlzUGFyZW50Rml4ZWQgPSBwb3BwZXJPZmZzZXRzLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdldCByZWZlcmVuY2UgZWxlbWVudCBwb3NpdGlvblxuICAgICAgICAvL1xuICAgICAgICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQ3VzdG9tUGFyZW50KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIGlzUGFyZW50Rml4ZWQpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdldCBwb3BwZXIgc2l6ZXNcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ29tcHV0ZSBvZmZzZXRzIG9mIHBvcHBlclxuICAgICAgICAvL1xuXG4gICAgICAgIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgICAgICAgaWYgKFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBvcHBlck9mZnNldHMudG9wID0gcmVmZXJlbmNlT2Zmc2V0cy50b3AgKyByZWZlcmVuY2VPZmZzZXRzLmhlaWdodCAvIDIgLSBwb3BwZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICBpZiAocGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBwb3BwZXJPZmZzZXRzLmxlZnQgPSByZWZlcmVuY2VPZmZzZXRzLmxlZnQgLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3BwZXJPZmZzZXRzLmxlZnQgPSByZWZlcmVuY2VPZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9wcGVyT2Zmc2V0cy5sZWZ0ID0gcmVmZXJlbmNlT2Zmc2V0cy5sZWZ0ICsgcmVmZXJlbmNlT2Zmc2V0cy53aWR0aCAvIDIgLSBwb3BwZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgcG9wcGVyT2Zmc2V0cy50b3AgPSByZWZlcmVuY2VPZmZzZXRzLnRvcCAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3BwZXJPZmZzZXRzLnRvcCA9IHJlZmVyZW5jZU9mZnNldHMuYm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gICAgICAgIHBvcHBlck9mZnNldHMud2lkdGggICA9IHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICAgIHBvcHBlck9mZnNldHMuaGVpZ2h0ICA9IHBvcHBlclJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3BwZXI6IHBvcHBlck9mZnNldHMsXG4gICAgICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZU9mZnNldHNcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVCb3VuZCA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5zdGF0ZS51cGRhdGVCb3VuZCk7XG4gICAgICAgIC8vIGlmIHRoZSBib3VuZGFyaWVzRWxlbWVudCBpcyB3aW5kb3cgd2UgZG9uJ3QgbmVlZCB0byBsaXN0ZW4gZm9yIHRoZSBzY3JvbGwgZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgIT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuX3JlZmVyZW5jZSk7XG4gICAgICAgICAgICAvLyBoZXJlIGl0IGNvdWxkIGJlIGJvdGggYGJvZHlgIG9yIGBkb2N1bWVudEVsZW1lbnRgIHRoYW5rcyB0byBGaXJlZm94LCB3ZSB0aGVuIGNoZWNrIGJvdGhcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHJvb3QuZG9jdW1lbnQuYm9keSB8fCB0YXJnZXQgPT09IHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2Nyb2xsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgIT09ICd3aW5kb3cnICYmIHRoaXMuc3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNjcm9sbFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydHkgXCJvZmZzZXRzXCIgZ2VuZXJhdGVkIGJ5IGBfZ2V0T2Zmc2V0c2BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFkZGluZyAtIEJvdW5kYXJpZXMgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLl9nZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24oZGF0YSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdmFyIGJvdW5kYXJpZXMgPSB7fTtcbiAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gcm9vdC5kb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICAgIGh0bWwgPSByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCApO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCggYm9keS5zY3JvbGxXaWR0aCwgYm9keS5vZmZzZXRXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5vZmZzZXRXaWR0aCApO1xuXG4gICAgICAgICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogd2lkdGgsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudCh0aGlzLl9wb3BwZXIpO1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLl9wb3BwZXIpO1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRPZmZzZXRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgICAgICAgICAgIC8vIFRoYW5rcyB0aGUgZnVja2luZyBuYXRpdmUgQVBJLCBgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BgICYgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BgXG4gICAgICAgICAgICB2YXIgZ2V0U2Nyb2xsVG9wVmFsdWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09IGRvY3VtZW50LmJvZHkgPyBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgOiBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZXRTY3JvbGxMZWZ0VmFsdWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09IGRvY3VtZW50LmJvZHkgPyBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSA6IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvcHBlciBpcyBmaXhlZCB3ZSBkb24ndCBoYXZlIHRvIHN1YnN0cmFjdCBzY3JvbGxpbmcgZnJvbSB0aGUgYm91bmRhcmllc1xuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPT09ICdmaXhlZCcgPyAwIDogZ2V0U2Nyb2xsVG9wVmFsdWUoc2Nyb2xsUGFyZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IDAgOiBnZXRTY3JvbGxMZWZ0VmFsdWUoc2Nyb2xsUGFyZW50KTtcblxuICAgICAgICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAgLSAob2Zmc2V0UGFyZW50UmVjdC50b3AgLSBzY3JvbGxUb3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIChvZmZzZXRQYXJlbnRSZWN0LmxlZnQgLSBzY3JvbGxMZWZ0KSxcbiAgICAgICAgICAgICAgICBib3R0b206IHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIChvZmZzZXRQYXJlbnRSZWN0LnRvcCAtIHNjcm9sbFRvcCksXG4gICAgICAgICAgICAgICAgbGVmdDogMCAtIChvZmZzZXRQYXJlbnRSZWN0LmxlZnQgLSBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZXRPZmZzZXRQYXJlbnQodGhpcy5fcG9wcGVyKSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBib3VuZGFyaWVzRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZGFyaWVzRWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzID0gZ2V0T2Zmc2V0UmVjdChib3VuZGFyaWVzRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IHBhZGRpbmc7XG4gICAgICAgIGJvdW5kYXJpZXMucmlnaHQgLT0gcGFkZGluZztcbiAgICAgICAgYm91bmRhcmllcy50b3AgPSBib3VuZGFyaWVzLnRvcCArIHBhZGRpbmc7XG4gICAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gYm91bmRhcmllcy5ib3R0b20gLSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gYm91bmRhcmllcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLCBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kc1xuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUucnVuTW9kaWZpZXJzID0gZnVuY3Rpb24oZGF0YSwgbW9kaWZpZXJzLCBlbmRzKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnNUb1J1biA9IG1vZGlmaWVycy5zbGljZSgpO1xuICAgICAgICBpZiAoZW5kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb2RpZmllcnNUb1J1biA9IHRoaXMuX29wdGlvbnMubW9kaWZpZXJzLnNsaWNlKDAsIGdldEFycmF5S2V5SW5kZXgodGhpcy5fb3B0aW9ucy5tb2RpZmllcnMsIGVuZHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtb2RpZmllci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZyAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWQgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuaXNNb2RpZmllclJlcXVpcmVkID0gZnVuY3Rpb24ocmVxdWVzdGluZywgcmVxdWVzdGVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEFycmF5S2V5SW5kZXgodGhpcy5fb3B0aW9ucy5tb2RpZmllcnMsIHJlcXVlc3RpbmcpO1xuICAgICAgICByZXR1cm4gISF0aGlzLl9vcHRpb25zLm1vZGlmaWVycy5zbGljZSgwLCBpbmRleCkuZmlsdGVyKGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZXIgPT09IHJlcXVlc3RlZDtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIE1vZGlmaWVyc1xuICAgIC8vXG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcnMgbGlzdFxuICAgICAqIEBuYW1lc3BhY2UgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzLmFwcGx5U3R5bGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIGFwcGx5IHRoZSBmaW5hbCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcm91bmQgdG9wIGFuZCBsZWZ0IHRvIGF2b2lkIGJsdXJyeSB0ZXh0XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5yb3VuZChkYXRhLm9mZnNldHMucG9wcGVyLmxlZnQpO1xuICAgICAgICB2YXIgdG9wID0gTWF0aC5yb3VuZChkYXRhLm9mZnNldHMucG9wcGVyLnRvcCk7XG5cbiAgICAgICAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byB0cnVlIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLCB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlclxuICAgICAgICAvLyB3ZSBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gICAgICAgIHZhciBwcmVmaXhlZFByb3BlcnR5O1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24gJiYgKHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpKSkge1xuICAgICAgICAgICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgICAgICAgICBzdHlsZXMudG9wID0gMDtcbiAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLmxlZnQgPWxlZnQ7XG4gICAgICAgICAgICBzdHlsZXMudG9wID0gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgICAgICAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgICAgICAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuXG4gICAgICAgIHNldFN0eWxlKHRoaXMuX3BvcHBlciwgc3R5bGVzKTtcblxuICAgICAgICAvLyBzZXQgYW4gYXR0cmlidXRlIHdoaWNoIHdpbGwgYmUgdXNlZnVsIHRvIHN0eWxlIHRoZSB0b29sdGlwICh1c2UgaXQgdG8gcHJvcGVybHkgcG9zaXRpb24gaXRzIGFycm93KVxuICAgICAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgICAgICB0aGlzLl9wb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIGRhdGEucGxhY2VtZW50KTtcblxuICAgICAgICAvLyBpZiB0aGUgYXJyb3cgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYW5kIHRoZSBhcnJvdyBzdHlsZSBoYXMgYmVlbiBjb21wdXRlZCwgYXBwbHkgdGhlIGFycm93IHN0eWxlXG4gICAgICAgIGlmICh0aGlzLmlzTW9kaWZpZXJSZXF1aXJlZCh0aGlzLm1vZGlmaWVycy5hcHBseVN0eWxlLCB0aGlzLm1vZGlmaWVycy5hcnJvdykgJiYgZGF0YS5vZmZzZXRzLmFycm93KSB7XG4gICAgICAgICAgICBzZXRTdHlsZShkYXRhLmFycm93RWxlbWVudCwgZGF0YS5vZmZzZXRzLmFycm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgc2lkZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMuc2hpZnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgICAgICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgdmFyIHNoaWZ0VmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgICAgICAgLy8gaWYgc2hpZnQgc2hpZnRWYXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gICAgICAgIGlmIChzaGlmdFZhcmlhdGlvbikge1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZSA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gICAgICAgICAgICB2YXIgcG9wcGVyID0gZ2V0UG9wcGVyQ2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAgICAgICAgICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAgeyB0b3A6IHJlZmVyZW5jZS50b3AgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAgICB7IHRvcDogcmVmZXJlbmNlLnRvcCArIHJlZmVyZW5jZS5oZWlnaHQgLSBwb3BwZXIuaGVpZ2h0IH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICB7IGxlZnQ6IHJlZmVyZW5jZS5sZWZ0IH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogICAgeyBsZWZ0OiByZWZlcmVuY2UubGVmdCArIHJlZmVyZW5jZS53aWR0aCAtIHBvcHBlci53aWR0aCB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGF4aXMgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMSA/ICd4JyA6ICd5JztcblxuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24ocG9wcGVyLCBzaGlmdE9mZnNldHNbYXhpc11bc2hpZnRWYXJpYXRpb25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSBwb3BwZXIgZG9lcyBub3Qgb3ZlcmZsb3dzIGZyb20gaXQncyBib3VuZGFyaWVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLm1vZGlmaWVycy5wcmV2ZW50T3ZlcmZsb3cgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBvcmRlciA9IHRoaXMuX29wdGlvbnMucHJldmVudE92ZXJmbG93T3JkZXI7XG4gICAgICAgIHZhciBwb3BwZXIgPSBnZXRQb3BwZXJDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gICAgICAgIHZhciBjaGVjayA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gcG9wcGVyLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHBlci5sZWZ0IDwgZGF0YS5ib3VuZGFyaWVzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KHBvcHBlci5sZWZ0LCBkYXRhLmJvdW5kYXJpZXMubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBwb3BwZXIubGVmdDtcbiAgICAgICAgICAgICAgICBpZiAocG9wcGVyLnJpZ2h0ID4gZGF0YS5ib3VuZGFyaWVzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihwb3BwZXIubGVmdCwgZGF0YS5ib3VuZGFyaWVzLnJpZ2h0IC0gcG9wcGVyLndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogbGVmdCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHBvcHBlci50b3A7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHBlci50b3AgPCBkYXRhLmJvdW5kYXJpZXMudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHBvcHBlci50b3AsIGRhdGEuYm91bmRhcmllcy50b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IHRvcCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHBvcHBlci50b3A7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHBlci5ib3R0b20gPiBkYXRhLmJvdW5kYXJpZXMuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHBvcHBlci50b3AsIGRhdGEuYm91bmRhcmllcy5ib3R0b20gLSBwb3BwZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24ocG9wcGVyLCBjaGVja1tkaXJlY3Rpb25dKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHBvcHBlciBpcyBhbHdheXMgbmVhciBpdHMgcmVmZXJlbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IF91cGRhdGUgbWV0aG9kXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzLmtlZXBUb2dldGhlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHBvcHBlciAgPSBnZXRQb3BwZXJDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgICAgICAgdmFyIGYgPSBNYXRoLmZsb29yO1xuXG4gICAgICAgIGlmIChwb3BwZXIucmlnaHQgPCBmKHJlZmVyZW5jZS5sZWZ0KSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlci5sZWZ0ID0gZihyZWZlcmVuY2UubGVmdCkgLSBwb3BwZXIud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHBlci5sZWZ0ID4gZihyZWZlcmVuY2UucmlnaHQpKSB7XG4gICAgICAgICAgICBkYXRhLm9mZnNldHMucG9wcGVyLmxlZnQgPSBmKHJlZmVyZW5jZS5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHBlci5ib3R0b20gPCBmKHJlZmVyZW5jZS50b3ApKSB7XG4gICAgICAgICAgICBkYXRhLm9mZnNldHMucG9wcGVyLnRvcCA9IGYocmVmZXJlbmNlLnRvcCkgLSBwb3BwZXIuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BwZXIudG9wID4gZihyZWZlcmVuY2UuYm90dG9tKSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlci50b3AgPSBmKHJlZmVyZW5jZS5ib3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIgd2hlbiB0aGUgbGF0dGVyIGlzIHN0YXJ0aW5nIG92ZXJsYXBwaW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAgICogKipOT1RFOioqIFRoaXMgbW9kaWZpZXIgd2lsbCBydW4gYWxsIGl0cyBwcmV2aW91cyBtb2RpZmllcnMgZXZlcnl0aW1lIGl0IHRyaWVzIHRvIGZsaXAgdGhlIHBvcHBlciFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAgICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgX3VwZGF0ZSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMuZmxpcCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgcHJldmVudE92ZXJmbG93IGlzIGluIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBiZWZvcmUgdGhlIGZsaXAgbW9kaWZpZXIuXG4gICAgICAgIC8vIG90aGVyd2lzZSBmbGlwIHdvdWxkIG5vdCB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICBpZiAoIXRoaXMuaXNNb2RpZmllclJlcXVpcmVkKHRoaXMubW9kaWZpZXJzLmZsaXAsIHRoaXMubW9kaWZpZXJzLnByZXZlbnRPdmVyZmxvdykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogcHJldmVudE92ZXJmbG93IG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5IGZsaXAgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSBmbGlwIScpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLl9vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgICAgICAgICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgICAgIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgICAgIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gICAgICAgIHZhciBmbGlwT3JkZXIgPSBbXTtcbiAgICAgICAgaWYodGhpcy5fb3B0aW9ucy5mbGlwQmVoYXZpb3IgPT09ICdmbGlwJykge1xuICAgICAgICAgICAgZmxpcE9yZGVyID0gW1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnRPcHBvc2l0ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsaXBPcmRlciA9IHRoaXMuX29wdGlvbnMuZmxpcEJlaGF2aW9yO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24oc3RlcCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgICAgICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGdldFBvcHBlckNsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgYm9vbGVhbiBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIHJpZ2h0IGFuZCBib3R0b20gZnJvbSB0b3AgYW5kIGxlZnRcbiAgICAgICAgICAgIC8vIHRoZXkgbmVlZCBkaWZmZXJlbnQgY29tcHV0YXRpb25zIHRvIGdldCBmbGlwcGVkXG4gICAgICAgICAgICB2YXIgYSA9IFsncmlnaHQnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgICAgICAgLy8gdXNpbmcgTWF0aC5mbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBhICYmIE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZVtwbGFjZW1lbnRdKSA+IE1hdGguZmxvb3IocG9wcGVyT2Zmc2V0c1twbGFjZW1lbnRPcHBvc2l0ZV0pIHx8XG4gICAgICAgICAgICAgICAgIWEgJiYgTWF0aC5mbG9vcihkYXRhLm9mZnNldHMucmVmZXJlbmNlW3BsYWNlbWVudF0pIDwgTWF0aC5mbG9vcihwb3BwZXJPZmZzZXRzW3BsYWNlbWVudE9wcG9zaXRlXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ2xsIHVzZSB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgICAgICAgICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRhdGEucGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBsYWNlbWVudCArPSAnLScgKyB2YXJpYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSB0aGlzLl9nZXRPZmZzZXRzKHRoaXMuX3BvcHBlciwgdGhpcy5fcmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkucG9wcGVyO1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMucnVuTW9kaWZpZXJzKGRhdGEsIHRoaXMuX29wdGlvbnMubW9kaWZpZXJzLCB0aGlzLl9mbGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gYWRkIGFuIG9mZnNldCB0byB0aGUgcG9wcGVyLCB1c2VmdWwgaWYgeW91IG1vcmUgZ3JhbnVsYXJpdHkgcG9zaXRpb25pbmcgeW91ciBwb3BwZXIuXG4gICAgICogVGhlIG9mZnNldHMgd2lsbCBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzaWRlIG9mIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAgICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgX3VwZGF0ZSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMub2Zmc2V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIHZhciBwb3BwZXIgID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAgICAgICBpZiAoZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignbGVmdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcG9wcGVyLnRvcCAtPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5wbGFjZW1lbnQuaW5kZXhPZigncmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEucGxhY2VtZW50LmluZGV4T2YoJ3RvcCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEucGxhY2VtZW50LmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xuICAgICAgICAgICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllciB1c2VkIHRvIG1vdmUgdGhlIGFycm93cyBvbiB0aGUgZWRnZSBvZiB0aGUgcG9wcGVyIHRvIG1ha2Ugc3VyZSB0aGVtIGFyZSBhbHdheXMgYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgKiBJdCB3aWxsIHVzZSB0aGUgQ1NTIG91dGVyIHNpemUgb2YgdGhlIGFycm93IGVsZW1lbnQgdG8ga25vdyBob3cgbWFueSBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IF91cGRhdGUgbWV0aG9kXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzLmFycm93ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgYXJyb3cgID0gdGhpcy5fb3B0aW9ucy5hcnJvd0VsZW1lbnQ7XG4gICAgICAgIHZhciBhcnJvd09mZnNldCA9IHRoaXMuX29wdGlvbnMuYXJyb3dPZmZzZXQ7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YgYXJyb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhcnJvdyA9IHRoaXMuX3BvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGFycm93IGVsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgICAgIGlmICghYXJyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGFycm93IGVsZW1lbnQgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyXG4gICAgICAgIGlmICghdGhpcy5fcG9wcGVyLmNvbnRhaW5zKGFycm93KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3dFbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICAgICAgICBpZiAoIXRoaXMuaXNNb2RpZmllclJlcXVpcmVkKHRoaXMubW9kaWZpZXJzLmFycm93LCB0aGlzLm1vZGlmaWVycy5rZWVwVG9nZXRoZXIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGtlZXBUb2dldGhlciBtb2RpZmllciBpcyByZXF1aXJlZCBieSBhcnJvdyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlIGFycm93IScpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyb3dTdHlsZSAgPSB7fTtcbiAgICAgICAgdmFyIHBsYWNlbWVudCAgID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgdmFyIHBvcHBlciAgICAgID0gZ2V0UG9wcGVyQ2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSAgID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgICAgICAgdmFyIGlzVmVydGljYWwgID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgICB2YXIgbGVuICAgICAgICAgPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICB2YXIgc2lkZSAgICAgICAgPSBpc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgICA9IGlzVmVydGljYWwgPyAndHJhbnNsYXRlWScgOiAndHJhbnNsYXRlWCc7XG4gICAgICAgIHZhciBhbHRTaWRlICAgICA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgdmFyIG9wU2lkZSAgICAgID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgdmFyIGFycm93U2l6ZSAgID0gZ2V0T3V0ZXJTaXplcyhhcnJvdylbbGVuXTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdWN0aW9uXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy8gdG9wL2xlZnQgc2lkZVxuICAgICAgICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd1NpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICAgICAgICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gKHJlZmVyZW5jZVtzaWRlXSArIGFycm93U2l6ZSkgLSBwb3BwZXJbb3BTaWRlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgICAgICAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIChhcnJvd09mZnNldCB8fCAocmVmZXJlbmNlW2xlbl0gLyAyKSAtIChhcnJvd1NpemUgLyAyKSk7XG5cbiAgICAgICAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIHBvcHBlcltzaWRlXTtcblxuICAgICAgICAvLyBwcmV2ZW50IGFycm93IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICAgICAgICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93U2l6ZSAtIDgsIHNpZGVWYWx1ZSksIDgpO1xuICAgICAgICBhcnJvd1N0eWxlW3NpZGVdID0gc2lkZVZhbHVlO1xuICAgICAgICBhcnJvd1N0eWxlW2FsdFNpZGVdID0gJyc7IC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgYW55IG9sZCBzdHlsZSBmcm9tIHRoZSBhcnJvd1xuXG4gICAgICAgIGRhdGEub2Zmc2V0cy5hcnJvdyA9IGFycm93U3R5bGU7XG4gICAgICAgIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3c7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuXG4gICAgLy9cbiAgICAvLyBIZWxwZXJzXG4gICAgLy9cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gICAgICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gICAgICAgIHZhciBfZGlzcGxheSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheSwgX3Zpc2liaWxpdHkgPSBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB2YXIgY2FsY1dpZHRoVG9Gb3JjZVJlcGFpbnQgPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICB2YXIgc3R5bGVzID0gcm9vdC5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0geyB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4IH07XG5cbiAgICAgICAgLy8gcmVzZXQgZWxlbWVudCBzdHlsZXNcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gX2Rpc3BsYXk7IGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IF92aXNpYmlsaXR5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmUvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgaGFzaCA9IHtsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gICAgICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uKG1hdGNoZWQpe1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBwb3BwZXIgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gICAgICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvcHBlckNsaWVudFJlY3QocG9wcGVyT2Zmc2V0cykge1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IE9iamVjdC5hc3NpZ24oe30sIHBvcHBlck9mZnNldHMpO1xuICAgICAgICBvZmZzZXRzLnJpZ2h0ID0gb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aDtcbiAgICAgICAgb2Zmc2V0cy5ib3R0b20gPSBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gb2Zmc2V0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBhbmQgdGhlIGtleSB0byBmaW5kLCByZXR1cm5zIGl0cyBpbmRleFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAgICAgKiBAYXJndW1lbnQga2V5VG9GaW5kXG4gICAgICogQHJldHVybnMgaW5kZXggb3IgbnVsbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFycmF5S2V5SW5kZXgoYXJyLCBrZXlUb0ZpbmQpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIGFycikge1xuICAgICAgICAgICAgaWYgKGFycltrZXldID09PSBrZXlUb0ZpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gICAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gICAgICAgIHZhciBjc3MgPSByb290LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjc3NbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgPT09IHJvb3QuZG9jdW1lbnQuYm9keSB8fCAhb2Zmc2V0UGFyZW50ID8gcm9vdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBvZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcm9vdC5kb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBwdXRzIHRoZSBzY3JvbGxUT3AgdmFsdWUgb24gYGRvY3VtZW50RWxlbWVudGAgaW5zdGVhZCBvZiBgYm9keWAsIHdlIHRoZW4gY2hlY2sgd2hpY2ggb2YgdGhlbSBpc1xuICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIDAgYW5kIHJldHVybiB0aGUgcHJvcGVyIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChyb290LmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IHJvb3QuZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIFsnc2Nyb2xsJywgJ2F1dG8nXS5pbmRleE9mKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQsICdvdmVyZmxvdycpKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIFsnc2Nyb2xsJywgJ2F1dG8nXS5pbmRleE9mKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQsICdvdmVyZmxvdy14JykpICE9PSAtMSB8fFxuICAgICAgICAgICAgWydzY3JvbGwnLCAnYXV0byddLmluZGV4T2YoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCwgJ292ZXJmbG93LXknKSkgIT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRldGVjdGVkIHNjcm9sbFBhcmVudCBpcyBib2R5LCB3ZSBwZXJmb3JtIGFuIGFkZGl0aW9uYWwgY2hlY2sgb24gaXRzIHBhcmVudE5vZGVcbiAgICAgICAgICAgIC8vIGluIHRoaXMgd2F5IHdlJ2xsIGdldCBib2R5IGlmIHRoZSBicm93c2VyIGlzIENocm9tZS1pc2gsIG9yIGRvY3VtZW50RWxlbWVudCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGZpeGVzIGlzc3VlICM2NVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHJvb3QuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgPyBpc0ZpeGVkKGVsZW1lbnQucGFyZW50Tm9kZSkgOiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXMgLSBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlcykge1xuICAgICAgICBmdW5jdGlvbiBpc19udW1lcmljKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAobiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSAnJztcbiAgICAgICAgICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzX251bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7Kn0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gICAgICAgIHZhciBnZXRUeXBlID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgcmVsYXRpdmUgdG8gaXRzIG9mZnNldCBwYXJlbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb3NpdGlvbiAtIENvb3JkaW5hdGVzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgYHNjcm9sbFRvcGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcFxuICAgICAgICB9O1xuXG4gICAgICAgIGVsZW1lbnRSZWN0LnJpZ2h0ID0gZWxlbWVudFJlY3QubGVmdCArIGVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICBlbGVtZW50UmVjdC5ib3R0b20gPSBlbGVtZW50UmVjdC50b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRSZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlIElFIHZlcnNpb24gaXMgbG93ZXIgdGhhbiAxMVxuICAgICAgICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT0gLTE7XG5cbiAgICAgICAgLy8gZml4IGllIGRvY3VtZW50IGJvdW5kaW5nIHRvcCBhbHdheXMgMCBidWdcbiAgICAgICAgdmFyIHJlY3RUb3AgPSBpc0lFICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gJ0hUTUwnXG4gICAgICAgICAgICA/IC1lbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgOiByZWN0LnRvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0VG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgICAgICAgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdFRvcFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGVsZW1lbnQgYW5kIG9uZSBvZiBpdHMgcGFyZW50cywgcmV0dXJuIHRoZSBvZmZzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQ3VzdG9tUGFyZW50KGVsZW1lbnQsIHBhcmVudCwgZml4ZWQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChwYXJlbnQpO1xuICAgICAgICAgICAgcGFyZW50UmVjdC50b3AgKz0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHBhcmVudFJlY3QuYm90dG9tICs9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBwYXJlbnRSZWN0LmxlZnQgKz0gc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwYXJlbnRSZWN0LnJpZ2h0ICs9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSB7XG4gICAgICAgICAgICB0b3A6IGVsZW1lbnRSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wICxcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRSZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLFxuICAgICAgICAgICAgYm90dG9tOiAoZWxlbWVudFJlY3QudG9wIC0gcGFyZW50UmVjdC50b3ApICsgZWxlbWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IChlbGVtZW50UmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0KSArIGVsZW1lbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50UmVjdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdtcycsICd3ZWJraXQnLCAnbW96JywgJ28nXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9DaGVjayA9IHByZWZpeGVzW2ldID8gcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpIDogcHJvcGVydHk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvb3QuZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9DaGVjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgT2JqZWN0LmFzc2lnbigpIG1ldGhvZCBpcyB1c2VkIHRvIGNvcHkgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gYSB0YXJnZXQgb2JqZWN0LiBJdCB3aWxsIHJldHVybiB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgKiBUaGlzIHBvbHlmaWxsIGRvZXNuJ3Qgc3VwcG9ydCBzeW1ib2wgcHJvcGVydGllcywgc2luY2UgRVM1IGRvZXNuJ3QgaGF2ZSBzeW1ib2xzIGFueXdheVxuICAgICAqIFNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2Fzc2lnbicsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0U291cmNlID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhuZXh0U291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBvcHBlcjtcbn0pKTtcbiIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBtZXJnZSBmcm9tICdlbGVtZW50LXVpL3NyYy91dGlscy9tZXJnZSc7XG5pbXBvcnQgUG9wdXBNYW5hZ2VyIGZyb20gJ2VsZW1lbnQtdWkvc3JjL3V0aWxzL3BvcHVwL3BvcHVwLW1hbmFnZXInO1xuaW1wb3J0IGdldFNjcm9sbEJhcldpZHRoIGZyb20gJy4uL3Njcm9sbGJhci13aWR0aCc7XG5pbXBvcnQgeyBnZXRTdHlsZSwgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBoYXNDbGFzcyB9IGZyb20gJy4uL2RvbSc7XG5cbmxldCBpZFNlZWQgPSAxO1xuXG5sZXQgc2Nyb2xsQmFyV2lkdGg7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9wZW5EZWxheToge30sXG4gICAgY2xvc2VEZWxheToge30sXG4gICAgekluZGV4OiB7fSxcbiAgICBtb2RhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBtb2RhbEZhZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RhbENsYXNzOiB7fSxcbiAgICBtb2RhbEFwcGVuZFRvQm9keToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsb2NrU2Nyb2xsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgY2xvc2VPblByZXNzRXNjYXBlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNsb3NlT25DbGlja01vZGFsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy5fcG9wdXBJZCA9ICdwb3B1cC0nICsgaWRTZWVkKys7XG4gICAgUG9wdXBNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMuX3BvcHVwSWQsIHRoaXMpO1xuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgUG9wdXBNYW5hZ2VyLmRlcmVnaXN0ZXIodGhpcy5fcG9wdXBJZCk7XG4gICAgUG9wdXBNYW5hZ2VyLmNsb3NlTW9kYWwodGhpcy5fcG9wdXBJZCk7XG5cbiAgICB0aGlzLnJlc3RvcmVCb2R5U3R5bGUoKTtcbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IGZhbHNlLFxuICAgICAgYm9keVBhZGRpbmdSaWdodDogbnVsbCxcbiAgICAgIGNvbXB1dGVkQm9keVBhZGRpbmdSaWdodDogMCxcbiAgICAgIHdpdGhvdXRIaWRkZW5DbGFzczogdHJ1ZSxcbiAgICAgIHJlbmRlcmVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICB2aXNpYmxlKHZhbCkge1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5fb3BlbmluZykgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICBWdWUubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG9wZW4ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IG1lcmdlKHt9LCB0aGlzLiRwcm9wcyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXIpO1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuVGltZXIpO1xuXG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBOdW1iZXIocHJvcHMub3BlbkRlbGF5KTtcbiAgICAgIGlmIChvcGVuRGVsYXkgPiAwKSB7XG4gICAgICAgIHRoaXMuX29wZW5UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX29wZW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5kb09wZW4ocHJvcHMpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb09wZW4ocHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkb09wZW4ocHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLiRpc1NlcnZlcikgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMud2lsbE9wZW4gJiYgIXRoaXMud2lsbE9wZW4oKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMub3BlbmVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX29wZW5pbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBkb20gPSB0aGlzLiRlbDtcblxuICAgICAgY29uc3QgbW9kYWwgPSBwcm9wcy5tb2RhbDtcblxuICAgICAgY29uc3QgekluZGV4ID0gcHJvcHMuekluZGV4O1xuICAgICAgaWYgKHpJbmRleCkge1xuICAgICAgICBQb3B1cE1hbmFnZXIuekluZGV4ID0gekluZGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NpbmcpIHtcbiAgICAgICAgICBQb3B1cE1hbmFnZXIuY2xvc2VNb2RhbCh0aGlzLl9wb3B1cElkKTtcbiAgICAgICAgICB0aGlzLl9jbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgUG9wdXBNYW5hZ2VyLm9wZW5Nb2RhbCh0aGlzLl9wb3B1cElkLCBQb3B1cE1hbmFnZXIubmV4dFpJbmRleCgpLCB0aGlzLm1vZGFsQXBwZW5kVG9Cb2R5ID8gdW5kZWZpbmVkIDogZG9tLCBwcm9wcy5tb2RhbENsYXNzLCBwcm9wcy5tb2RhbEZhZGUpO1xuICAgICAgICBpZiAocHJvcHMubG9ja1Njcm9sbCkge1xuICAgICAgICAgIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzID0gIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksICdlbC1wb3B1cC1wYXJlbnQtLWhpZGRlbicpO1xuICAgICAgICAgIGlmICh0aGlzLndpdGhvdXRIaWRkZW5DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5ib2R5UGFkZGluZ1JpZ2h0ID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkQm9keVBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGdldFN0eWxlKGRvY3VtZW50LmJvZHksICdwYWRkaW5nUmlnaHQnKSwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxCYXJXaWR0aCA9IGdldFNjcm9sbEJhcldpZHRoKCk7XG4gICAgICAgICAgbGV0IGJvZHlIYXNPdmVyZmxvdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICBsZXQgYm9keU92ZXJmbG93WSA9IGdldFN0eWxlKGRvY3VtZW50LmJvZHksICdvdmVyZmxvd1knKTtcbiAgICAgICAgICBpZiAoc2Nyb2xsQmFyV2lkdGggPiAwICYmIChib2R5SGFzT3ZlcmZsb3cgfHwgYm9keU92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpICYmIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuY29tcHV0ZWRCb2R5UGFkZGluZ1JpZ2h0ICsgc2Nyb2xsQmFyV2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnZWwtcG9wdXAtcGFyZW50LS1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShkb20pLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgfVxuXG4gICAgICBkb20uc3R5bGUuekluZGV4ID0gUG9wdXBNYW5hZ2VyLm5leHRaSW5kZXgoKTtcbiAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5vbk9wZW4gJiYgdGhpcy5vbk9wZW4oKTtcblxuICAgICAgdGhpcy5kb0FmdGVyT3BlbigpO1xuICAgIH0sXG5cbiAgICBkb0FmdGVyT3BlbigpIHtcbiAgICAgIHRoaXMuX29wZW5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy53aWxsQ2xvc2UgJiYgIXRoaXMud2lsbENsb3NlKCkpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMuX29wZW5UaW1lciAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlblRpbWVyKTtcbiAgICAgICAgdGhpcy5fb3BlblRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jbG9zZVRpbWVyKTtcblxuICAgICAgY29uc3QgY2xvc2VEZWxheSA9IE51bWJlcih0aGlzLmNsb3NlRGVsYXkpO1xuXG4gICAgICBpZiAoY2xvc2VEZWxheSA+IDApIHtcbiAgICAgICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgICB9LCBjbG9zZURlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgdGhpcy5fY2xvc2luZyA9IHRydWU7XG5cbiAgICAgIHRoaXMub25DbG9zZSAmJiB0aGlzLm9uQ2xvc2UoKTtcblxuICAgICAgaWYgKHRoaXMubG9ja1Njcm9sbCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVzdG9yZUJvZHlTdHlsZSwgMjAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5kb0FmdGVyQ2xvc2UoKTtcbiAgICB9LFxuXG4gICAgZG9BZnRlckNsb3NlKCkge1xuICAgICAgUG9wdXBNYW5hZ2VyLmNsb3NlTW9kYWwodGhpcy5fcG9wdXBJZCk7XG4gICAgICB0aGlzLl9jbG9zaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RvcmVCb2R5U3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCAmJiB0aGlzLndpdGhvdXRIaWRkZW5DbGFzcykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuYm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2VsLXBvcHVwLXBhcmVudC0taGlkZGVuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLndpdGhvdXRIaWRkZW5DbGFzcyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQge1xuICBQb3B1cE1hbmFnZXJcbn07XG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgeyBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MgfSBmcm9tICdlbGVtZW50LXVpL3NyYy91dGlscy9kb20nO1xuXG5sZXQgaGFzTW9kYWwgPSBmYWxzZTtcbmxldCBoYXNJbml0WkluZGV4ID0gZmFsc2U7XG5sZXQgekluZGV4O1xuXG5jb25zdCBnZXRNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXIpIHJldHVybjtcbiAgbGV0IG1vZGFsRG9tID0gUG9wdXBNYW5hZ2VyLm1vZGFsRG9tO1xuICBpZiAobW9kYWxEb20pIHtcbiAgICBoYXNNb2RhbCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaGFzTW9kYWwgPSBmYWxzZTtcbiAgICBtb2RhbERvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFBvcHVwTWFuYWdlci5tb2RhbERvbSA9IG1vZGFsRG9tO1xuXG4gICAgbW9kYWxEb20uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIG1vZGFsRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBQb3B1cE1hbmFnZXIuZG9Pbk1vZGFsQ2xpY2sgJiYgUG9wdXBNYW5hZ2VyLmRvT25Nb2RhbENsaWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbW9kYWxEb207XG59O1xuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcblxuY29uc3QgUG9wdXBNYW5hZ2VyID0ge1xuICBtb2RhbEZhZGU6IHRydWUsXG5cbiAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG4gIH0sXG5cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGlkLCBpbnN0YW5jZSkge1xuICAgIGlmIChpZCAmJiBpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2VzW2lkXSA9IGluc3RhbmNlO1xuICAgIH1cbiAgfSxcblxuICBkZXJlZ2lzdGVyOiBmdW5jdGlvbihpZCkge1xuICAgIGlmIChpZCkge1xuICAgICAgaW5zdGFuY2VzW2lkXSA9IG51bGw7XG4gICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgbmV4dFpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBvcHVwTWFuYWdlci56SW5kZXgrKztcbiAgfSxcblxuICBtb2RhbFN0YWNrOiBbXSxcblxuICBkb09uTW9kYWxDbGljazogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdG9wSXRlbSA9IFBvcHVwTWFuYWdlci5tb2RhbFN0YWNrW1BvcHVwTWFuYWdlci5tb2RhbFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghdG9wSXRlbSkgcmV0dXJuO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBQb3B1cE1hbmFnZXIuZ2V0SW5zdGFuY2UodG9wSXRlbS5pZCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmNsb3NlT25DbGlja01vZGFsKSB7XG4gICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgIH1cbiAgfSxcblxuICBvcGVuTW9kYWw6IGZ1bmN0aW9uKGlkLCB6SW5kZXgsIGRvbSwgbW9kYWxDbGFzcywgbW9kYWxGYWRlKSB7XG4gICAgaWYgKFZ1ZS5wcm90b3R5cGUuJGlzU2VydmVyKSByZXR1cm47XG4gICAgaWYgKCFpZCB8fCB6SW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIHRoaXMubW9kYWxGYWRlID0gbW9kYWxGYWRlO1xuXG4gICAgY29uc3QgbW9kYWxTdGFjayA9IHRoaXMubW9kYWxTdGFjaztcblxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbW9kYWxTdGFjay5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtb2RhbFN0YWNrW2ldO1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtb2RhbERvbSA9IGdldE1vZGFsKCk7XG5cbiAgICBhZGRDbGFzcyhtb2RhbERvbSwgJ3YtbW9kYWwnKTtcbiAgICBpZiAodGhpcy5tb2RhbEZhZGUgJiYgIWhhc01vZGFsKSB7XG4gICAgICBhZGRDbGFzcyhtb2RhbERvbSwgJ3YtbW9kYWwtZW50ZXInKTtcbiAgICB9XG4gICAgaWYgKG1vZGFsQ2xhc3MpIHtcbiAgICAgIGxldCBjbGFzc0FyciA9IG1vZGFsQ2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICBjbGFzc0Fyci5mb3JFYWNoKGl0ZW0gPT4gYWRkQ2xhc3MobW9kYWxEb20sIGl0ZW0pKTtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVDbGFzcyhtb2RhbERvbSwgJ3YtbW9kYWwtZW50ZXInKTtcbiAgICB9LCAyMDApO1xuXG4gICAgaWYgKGRvbSAmJiBkb20ucGFyZW50Tm9kZSAmJiBkb20ucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAgIGRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG1vZGFsRG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtb2RhbERvbSk7XG4gICAgfVxuXG4gICAgaWYgKHpJbmRleCkge1xuICAgICAgbW9kYWxEb20uc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgIH1cbiAgICBtb2RhbERvbS50YWJJbmRleCA9IDA7XG4gICAgbW9kYWxEb20uc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgdGhpcy5tb2RhbFN0YWNrLnB1c2goeyBpZDogaWQsIHpJbmRleDogekluZGV4LCBtb2RhbENsYXNzOiBtb2RhbENsYXNzIH0pO1xuICB9LFxuXG4gIGNsb3NlTW9kYWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgY29uc3QgbW9kYWxTdGFjayA9IHRoaXMubW9kYWxTdGFjaztcbiAgICBjb25zdCBtb2RhbERvbSA9IGdldE1vZGFsKCk7XG5cbiAgICBpZiAobW9kYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3BJdGVtID0gbW9kYWxTdGFja1ttb2RhbFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHRvcEl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgIGlmICh0b3BJdGVtLm1vZGFsQ2xhc3MpIHtcbiAgICAgICAgICBsZXQgY2xhc3NBcnIgPSB0b3BJdGVtLm1vZGFsQ2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgY2xhc3NBcnIuZm9yRWFjaChpdGVtID0+IHJlbW92ZUNsYXNzKG1vZGFsRG9tLCBpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAobW9kYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbW9kYWxEb20uc3R5bGUuekluZGV4ID0gbW9kYWxTdGFja1ttb2RhbFN0YWNrLmxlbmd0aCAtIDFdLnpJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1vZGFsU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobW9kYWxTdGFja1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIG1vZGFsU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGFsU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbEZhZGUpIHtcbiAgICAgICAgYWRkQ2xhc3MobW9kYWxEb20sICd2LW1vZGFsLWxlYXZlJyk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKG1vZGFsU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKG1vZGFsRG9tLnBhcmVudE5vZGUpIG1vZGFsRG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobW9kYWxEb20pO1xuICAgICAgICAgIG1vZGFsRG9tLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgUG9wdXBNYW5hZ2VyLm1vZGFsRG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNsYXNzKG1vZGFsRG9tLCAndi1tb2RhbC1sZWF2ZScpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3B1cE1hbmFnZXIsICd6SW5kZXgnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIGlmICghaGFzSW5pdFpJbmRleCkge1xuICAgICAgekluZGV4ID0gekluZGV4IHx8IChWdWUucHJvdG90eXBlLiRFTEVNRU5UIHx8IHt9KS56SW5kZXggfHwgMjAwMDtcbiAgICAgIGhhc0luaXRaSW5kZXggPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gekluZGV4O1xuICB9LFxuICBzZXQodmFsdWUpIHtcbiAgICB6SW5kZXggPSB2YWx1ZTtcbiAgfVxufSk7XG5cbmNvbnN0IGdldFRvcFBvcHVwID0gZnVuY3Rpb24oKSB7XG4gIGlmIChWdWUucHJvdG90eXBlLiRpc1NlcnZlcikgcmV0dXJuO1xuICBpZiAoUG9wdXBNYW5hZ2VyLm1vZGFsU3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHRvcFBvcHVwID0gUG9wdXBNYW5hZ2VyLm1vZGFsU3RhY2tbUG9wdXBNYW5hZ2VyLm1vZGFsU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKCF0b3BQb3B1cCkgcmV0dXJuO1xuICAgIGNvbnN0IGluc3RhbmNlID0gUG9wdXBNYW5hZ2VyLmdldEluc3RhbmNlKHRvcFBvcHVwLmlkKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxufTtcblxuaWYgKCFWdWUucHJvdG90eXBlLiRpc1NlcnZlcikge1xuICAvLyBoYW5kbGUgYGVzY2Aga2V5IHdoZW4gdGhlIHBvcHVwIGlzIHNob3duXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgIGNvbnN0IHRvcFBvcHVwID0gZ2V0VG9wUG9wdXAoKTtcblxuICAgICAgaWYgKHRvcFBvcHVwICYmIHRvcFBvcHVwLmNsb3NlT25QcmVzc0VzY2FwZSkge1xuICAgICAgICB0b3BQb3B1cC5oYW5kbGVDbG9zZVxuICAgICAgICAgID8gdG9wUG9wdXAuaGFuZGxlQ2xvc2UoKVxuICAgICAgICAgIDogKHRvcFBvcHVwLmhhbmRsZUFjdGlvbiA/IHRvcFBvcHVwLmhhbmRsZUFjdGlvbignY2FuY2VsJykgOiB0b3BQb3B1cC5jbG9zZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb3B1cE1hbmFnZXI7XG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbmxldCBzY3JvbGxCYXJXaWR0aDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGlmIChWdWUucHJvdG90eXBlLiRpc1NlcnZlcikgcmV0dXJuIDA7XG4gIGlmIChzY3JvbGxCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2Nyb2xsQmFyV2lkdGg7XG5cbiAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgb3V0ZXIuY2xhc3NOYW1lID0gJ2VsLXNjcm9sbGJhcl9fd3JhcCc7XG4gIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICBvdXRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIG91dGVyLnN0eWxlLnRvcCA9ICctOTk5OXB4JztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG5cbiAgY29uc3Qgd2lkdGhOb1Njcm9sbCA9IG91dGVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuXG4gIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgY29uc3Qgd2lkdGhXaXRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICBzY3JvbGxCYXJXaWR0aCA9IHdpZHRoTm9TY3JvbGwgLSB3aWR0aFdpdGhTY3JvbGw7XG5cbiAgcmV0dXJuIHNjcm9sbEJhcldpZHRoO1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0tvcmVhbih0ZXh0KSB7XG4gIGNvbnN0IHJlZyA9IC8oWyhcXHVBQzAwLVxcdUQ3QUYpfChcXHUzMTMwLVxcdTMxOEYpXSkrL2dpO1xuICByZXR1cm4gcmVnLnRlc3QodGV4dCk7XG59XG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIdG1sRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuXG4vKipcbiAqICAtIEluc3BpcmVkOlxuICogICAgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvbWFzdGVyL21vZHVsZXMvaXNGdW5jdGlvbi5qc1xuICovXG5sZXQgaXNGdW5jdGlvbiA9IChmdW5jdGlvblRvQ2hlY2spID0+IHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbmlmICh0eXBlb2YgLy4vICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT09ICdvYmplY3QnICYmIChWdWUucHJvdG90eXBlLiRpc1NlcnZlciB8fCB0eXBlb2YgZG9jdW1lbnQuY2hpbGROb2RlcyAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9O1xufVxuXG5leHBvcnQge1xuICBpc0Z1bmN0aW9uXG59O1xuXG5leHBvcnQgY29uc3QgaXNVbmRlZmluZWQgPSAodmFsKT0+IHtcbiAgcmV0dXJuIHZhbCA9PT0gdm9pZCAwO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRGVmaW5lZCA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbDtcbn07XG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNPYmplY3QgfSBmcm9tICdlbGVtZW50LXVpL3NyYy91dGlscy90eXBlcyc7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XG4gIGZvciAobGV0IGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0bztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b09iamVjdChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VmFsdWVCeVBhdGggPSBmdW5jdGlvbihvYmplY3QsIHByb3ApIHtcbiAgcHJvcCA9IHByb3AgfHwgJyc7XG4gIGNvbnN0IHBhdGhzID0gcHJvcC5zcGxpdCgnLicpO1xuICBsZXQgY3VycmVudCA9IG9iamVjdDtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gcGF0aHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmICghY3VycmVudCkgYnJlYWs7XG5cbiAgICBpZiAoaSA9PT0gaiAtIDEpIHtcbiAgICAgIHJlc3VsdCA9IGN1cnJlbnRbcGF0aF07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wQnlQYXRoKG9iaiwgcGF0aCwgc3RyaWN0KSB7XG4gIGxldCB0ZW1wT2JqID0gb2JqO1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgJy4kMScpO1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuLywgJycpO1xuXG4gIGxldCBrZXlBcnIgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgbGVuID0ga2V5QXJyLmxlbmd0aDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgIGlmICghdGVtcE9iaiAmJiAhc3RyaWN0KSBicmVhaztcbiAgICBsZXQga2V5ID0ga2V5QXJyW2ldO1xuICAgIGlmIChrZXkgaW4gdGVtcE9iaikge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSB0cmFuc2ZlciBhIHZhbGlkIHByb3AgcGF0aCB0byBmb3JtIGl0ZW0hJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvOiB0ZW1wT2JqLFxuICAgIGs6IGtleUFycltpXSxcbiAgICB2OiB0ZW1wT2JqID8gdGVtcE9ialtrZXlBcnJbaV1dIDogbnVsbFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbn07XG5cbmV4cG9ydCBjb25zdCB2YWx1ZUVxdWFscyA9IChhLCBiKSA9PiB7XG4gIC8vIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExNTk4Mi9ob3ctdG8tY2hlY2staWYtdHdvLWFycmF5cy1hcmUtZXF1YWwtd2l0aC1qYXZhc2NyaXB0XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIEFycmF5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIShiIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGVzY2FwZVJlZ2V4cFN0cmluZyA9ICh2YWx1ZSA9ICcnKSA9PiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJyk7XG5cbi8vIFRPRE86IHVzZSBuYXRpdmUgQXJyYXkuZmluZCwgQXJyYXkuZmluZEluZGV4IHdoZW4gSUUgc3VwcG9ydCBpcyBkcm9wcGVkXG5leHBvcnQgY29uc3QgYXJyYXlGaW5kSW5kZXggPSBmdW5jdGlvbihhcnIsIHByZWQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcmVkKGFycltpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5leHBvcnQgY29uc3QgYXJyYXlGaW5kID0gZnVuY3Rpb24oYXJyLCBwcmVkKSB7XG4gIGNvbnN0IGlkeCA9IGFycmF5RmluZEluZGV4KGFyciwgcHJlZCk7XG4gIHJldHVybiBpZHggIT09IC0xID8gYXJyW2lkeF0gOiB1bmRlZmluZWQ7XG59O1xuXG4vLyBjb2VyY2UgdHJ1dGh5IHZhbHVlIHRvIGFycmF5XG5leHBvcnQgY29uc3QgY29lcmNlVHJ1dGh5VmFsdWVUb0FycmF5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKHZhbCkge1xuICAgIHJldHVybiBbdmFsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc0lFID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgIWlzTmFOKE51bWJlcihkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0VkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICFWdWUucHJvdG90eXBlLiRpc1NlcnZlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA+IC0xO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRmlyZWZveCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIVZ1ZS5wcm90b3R5cGUuJGlzU2VydmVyICYmICEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3gvaSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXV0b3ByZWZpeGVyID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHJldHVybiBzdHlsZTtcbiAgY29uc3QgcnVsZXMgPSBbJ3RyYW5zZm9ybScsICd0cmFuc2l0aW9uJywgJ2FuaW1hdGlvbiddO1xuICBjb25zdCBwcmVmaXhlcyA9IFsnbXMtJywgJ3dlYmtpdC0nXTtcbiAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlW3J1bGVdO1xuICAgIGlmIChydWxlICYmIHZhbHVlKSB7XG4gICAgICBwcmVmaXhlcy5mb3JFYWNoKHByZWZpeCA9PiB7XG4gICAgICAgIHN0eWxlW3ByZWZpeCArIHJ1bGVdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG5leHBvcnQgY29uc3Qga2ViYWJDYXNlID0gZnVuY3Rpb24oc3RyKSB7XG4gIGNvbnN0IGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKCFpc1N0cmluZyhzdHIpKSByZXR1cm4gc3RyO1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvb3NlRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGNvbnN0IGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICBjb25zdCBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUVxdWFscyA9IGZ1bmN0aW9uKGFycmF5QSwgYXJyYXlCKSB7XG4gIGFycmF5QSA9IGFycmF5QSB8fCBbXTtcbiAgYXJyYXlCID0gYXJyYXlCIHx8IFtdO1xuXG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWxvb3NlRXF1YWwoYXJyYXlBW2ldLCBhcnJheUJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgaXNFcXVhbCA9IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpKSB7XG4gICAgcmV0dXJuIGFycmF5RXF1YWxzKHZhbHVlMSwgdmFsdWUyKTtcbiAgfVxuICByZXR1cm4gbG9vc2VFcXVhbCh2YWx1ZTEsIHZhbHVlMik7XG59O1xuXG5leHBvcnQgY29uc3QgaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbCkge1xuICAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAodmFsID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHJldHVybiAhdmFsO1xuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5tZXNzYWdlID09PSAnJztcblxuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgLy8gU3RyaW5nIG9yIEFycmF5XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICByZXR1cm4gIXZhbC5sZW5ndGg7XG5cbiAgICAvLyBNYXAgb3IgU2V0IG9yIEZpbGVcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IE1hcF0nOlxuICAgIGNhc2UgJ1tvYmplY3QgU2V0XSc6IHtcbiAgICAgIHJldHVybiAhdmFsLnNpemU7XG4gICAgfVxuICAgIC8vIFBsYWluIE9iamVjdFxuICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHtcbiAgICAgIHJldHVybiAhT2JqZWN0LmtleXModmFsKS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZlRocm90dGxlKGZuKSB7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAobG9ja2VkKSByZXR1cm47XG4gICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF8gPT4ge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICBsb2NrZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvQXJyYXkob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBpc0VtcHR5KG9iaikgPyBbXSA6IFtvYmpdO1xufVxuIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IHtcbiAgUG9wdXBNYW5hZ2VyXG59IGZyb20gJ2VsZW1lbnQtdWkvc3JjL3V0aWxzL3BvcHVwJztcblxuY29uc3QgUG9wcGVySlMgPSBWdWUucHJvdG90eXBlLiRpc1NlcnZlciA/IGZ1bmN0aW9uKCkge30gOiByZXF1aXJlKCcuL3BvcHBlcicpO1xuY29uc3Qgc3RvcCA9IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbcmVmZXJlbmNlPSRyZWZzLnJlZmVyZW5jZV0gLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3BvcHBlcj0kcmVmcy5wb3BwZXJdIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlciwgb3IgYSBjb25maWd1cmF0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHBvcHBlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGxhY2VtZW50PWJ1dHRvbl0gLSBQbGFjZW1lbnQgb2YgdGhlIHBvcHBlciBhY2NlcHRlZCB2YWx1ZXM6IHRvcCgtc3RhcnQsIC1lbmQpLCByaWdodCgtc3RhcnQsIC1lbmQpLCBib3R0b20oLXN0YXJ0LCAtZW5kKSwgbGVmdCgtc3RhcnQsIC1lbmQpXG4gKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXSAtIEFtb3VudCBvZiBwaXhlbHMgdGhlIHBvcHBlciB3aWxsIGJlIHNoaWZ0ZWQgKGNhbiBiZSBuZWdhdGl2ZSkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2aXNpYmxlPWZhbHNlXSBWaXNpYmlsaXR5IG9mIHRoZSBwb3B1cCBlbGVtZW50LlxuICogQHBhcmFtIHtCb29sZWFufSBbdmlzaWJsZS1hcnJvdz1mYWxzZV0gVmlzaWJpbGl0eSBvZiB0aGUgYXJyb3csIG5vIHN0eWxlLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIHBsYWNlbWVudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2JvdHRvbSdcbiAgICB9LFxuICAgIGJvdW5kYXJpZXNQYWRkaW5nOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiA1XG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9LFxuICAgIHBvcHBlcjoge30sXG4gICAgb2Zmc2V0OiB7XG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICB2YWx1ZTogQm9vbGVhbixcbiAgICB2aXNpYmxlQXJyb3c6IEJvb2xlYW4sXG4gICAgYXJyb3dPZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDM1XG4gICAgfSxcbiAgICBhcHBlbmRUb0JvZHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBwb3BwZXJPcHRpb25zOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd1BvcHBlcjogZmFsc2UsXG4gICAgICBjdXJyZW50UGxhY2VtZW50OiAnJ1xuICAgIH07XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZToge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcih2YWwpIHtcbiAgICAgICAgdGhpcy5zaG93UG9wcGVyID0gdmFsO1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHZhbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNob3dQb3BwZXIodmFsKSB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgdmFsID8gdGhpcy51cGRhdGVQb3BwZXIoKSA6IHRoaXMuZGVzdHJveVBvcHBlcigpO1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWwpO1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgY3JlYXRlUG9wcGVyKCkge1xuICAgICAgaWYgKHRoaXMuJGlzU2VydmVyKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnJlbnRQbGFjZW1lbnQgPSB0aGlzLmN1cnJlbnRQbGFjZW1lbnQgfHwgdGhpcy5wbGFjZW1lbnQ7XG4gICAgICBpZiAoIS9eKHRvcHxib3R0b218bGVmdHxyaWdodCkoLXN0YXJ0fC1lbmQpPyQvZy50ZXN0KHRoaXMuY3VycmVudFBsYWNlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5wb3BwZXJPcHRpb25zO1xuICAgICAgY29uc3QgcG9wcGVyID0gdGhpcy5wb3BwZXJFbG0gPSB0aGlzLnBvcHBlckVsbSB8fCB0aGlzLnBvcHBlciB8fCB0aGlzLiRyZWZzLnBvcHBlcjtcbiAgICAgIGxldCByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZUVsbSA9IHRoaXMucmVmZXJlbmNlRWxtIHx8IHRoaXMucmVmZXJlbmNlIHx8IHRoaXMuJHJlZnMucmVmZXJlbmNlO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSAmJlxuICAgICAgICB0aGlzLiRzbG90cy5yZWZlcmVuY2UgJiZcbiAgICAgICAgdGhpcy4kc2xvdHMucmVmZXJlbmNlWzBdKSB7XG4gICAgICAgIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlRWxtID0gdGhpcy4kc2xvdHMucmVmZXJlbmNlWzBdLmVsbTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwb3BwZXIgfHwgIXJlZmVyZW5jZSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMudmlzaWJsZUFycm93KSB0aGlzLmFwcGVuZEFycm93KHBvcHBlcik7XG4gICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3BwZXJFbG0pO1xuICAgICAgaWYgKHRoaXMucG9wcGVySlMgJiYgdGhpcy5wb3BwZXJKUy5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMucG9wcGVySlMuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLnBsYWNlbWVudCA9IHRoaXMuY3VycmVudFBsYWNlbWVudDtcbiAgICAgIG9wdGlvbnMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICBvcHRpb25zLmFycm93T2Zmc2V0ID0gdGhpcy5hcnJvd09mZnNldDtcbiAgICAgIHRoaXMucG9wcGVySlMgPSBuZXcgUG9wcGVySlMocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5wb3BwZXJKUy5vbkNyZWF0ZShfID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY3JlYXRlZCcsIHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtT3JpZ2luKCk7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlUG9wcGVyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucG9wcGVySlMub25VcGRhdGUob3B0aW9ucy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcHBlckpTLl9wb3BwZXIuc3R5bGUuekluZGV4ID0gUG9wdXBNYW5hZ2VyLm5leHRaSW5kZXgoKTtcbiAgICAgIHRoaXMucG9wcGVyRWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3RvcCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVBvcHBlcigpIHtcbiAgICAgIGNvbnN0IHBvcHBlckpTID0gdGhpcy5wb3BwZXJKUztcbiAgICAgIGlmIChwb3BwZXJKUykge1xuICAgICAgICBwb3BwZXJKUy51cGRhdGUoKTtcbiAgICAgICAgaWYgKHBvcHBlckpTLl9wb3BwZXIpIHtcbiAgICAgICAgICBwb3BwZXJKUy5fcG9wcGVyLnN0eWxlLnpJbmRleCA9IFBvcHVwTWFuYWdlci5uZXh0WkluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3JlYXRlUG9wcGVyKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRvRGVzdHJveShmb3JjZURlc3Ryb3kpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF0aGlzLnBvcHBlckpTIHx8ICh0aGlzLnNob3dQb3BwZXIgJiYgIWZvcmNlRGVzdHJveSkpIHJldHVybjtcbiAgICAgIHRoaXMucG9wcGVySlMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5wb3BwZXJKUyA9IG51bGw7XG4gICAgfSxcblxuICAgIGRlc3Ryb3lQb3BwZXIoKSB7XG4gICAgICBpZiAodGhpcy5wb3BwZXJKUykge1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtT3JpZ2luKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0VHJhbnNmb3JtT3JpZ2luKCkge1xuICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybU9yaWdpbikgcmV0dXJuO1xuICAgICAgbGV0IHBsYWNlbWVudE1hcCA9IHtcbiAgICAgICAgdG9wOiAnYm90dG9tJyxcbiAgICAgICAgYm90dG9tOiAndG9wJyxcbiAgICAgICAgbGVmdDogJ3JpZ2h0JyxcbiAgICAgICAgcmlnaHQ6ICdsZWZ0J1xuICAgICAgfTtcbiAgICAgIGxldCBwbGFjZW1lbnQgPSB0aGlzLnBvcHBlckpTLl9wb3BwZXIuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpLnNwbGl0KCctJylbMF07XG4gICAgICBsZXQgb3JpZ2luID0gcGxhY2VtZW50TWFwW3BsYWNlbWVudF07XG4gICAgICB0aGlzLnBvcHBlckpTLl9wb3BwZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHlwZW9mIHRoaXMudHJhbnNmb3JtT3JpZ2luID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXMudHJhbnNmb3JtT3JpZ2luXG4gICAgICAgIDogWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID4gLTEgPyBgY2VudGVyICR7IG9yaWdpbiB9YCA6IGAkeyBvcmlnaW4gfSBjZW50ZXJgO1xuICAgIH0sXG5cbiAgICBhcHBlbmRBcnJvdyhlbGVtZW50KSB7XG4gICAgICBsZXQgaGFzaDtcbiAgICAgIGlmICh0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG5cbiAgICAgIGZvciAobGV0IGl0ZW0gaW4gZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICgvXl92LS8udGVzdChlbGVtZW50LmF0dHJpYnV0ZXNbaXRlbV0ubmFtZSkpIHtcbiAgICAgICAgICBoYXNoID0gZWxlbWVudC5hdHRyaWJ1dGVzW2l0ZW1dLm5hbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKGhhc2gpIHtcbiAgICAgICAgYXJyb3cuc2V0QXR0cmlidXRlKGhhc2gsICcnKTtcbiAgICAgIH1cbiAgICAgIGFycm93LnNldEF0dHJpYnV0ZSgneC1hcnJvdycsICcnKTtcbiAgICAgIGFycm93LmNsYXNzTmFtZSA9ICdwb3BwZXJfX2Fycm93JztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZG9EZXN0cm95KHRydWUpO1xuICAgIGlmICh0aGlzLnBvcHBlckVsbSAmJiB0aGlzLnBvcHBlckVsbS5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB0aGlzLnBvcHBlckVsbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN0b3ApO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlckVsbSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIGNhbGwgZGVzdHJveSBpbiBrZWVwLWFsaXZlIG1vZGVcbiAgZGVhY3RpdmF0ZWQoKSB7XG4gICAgdGhpcy4kb3B0aW9ucy5iZWZvcmVEZXN0cm95WzBdLmNhbGwodGhpcyk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2J1dHRvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MGMyZGVlMmEmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vYnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vYnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvaG9tZS9wYW5hL3dvcmtzcGFjZS9nb29nbGUveXh0eC9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcwYzJkZWUyYScpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcwYzJkZWUyYScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcwYzJkZWUyYScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vYnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wYzJkZWUyYSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcwYzJkZWUyYScsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwibm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvcGFja2FnZXMvYnV0dG9uL3NyYy9idXR0b24udnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPHRlbXBsYXRlPlxuICA8YnV0dG9uXG4gICAgY2xhc3M9XCJlbC1idXR0b25cIlxuICAgIEBjbGljaz1cImhhbmRsZUNsaWNrXCJcbiAgICA6ZGlzYWJsZWQ9XCJidXR0b25EaXNhYmxlZCB8fCBsb2FkaW5nXCJcbiAgICA6YXV0b2ZvY3VzPVwiYXV0b2ZvY3VzXCJcbiAgICA6dHlwZT1cIm5hdGl2ZVR5cGVcIlxuICAgIDpjbGFzcz1cIltcbiAgICAgIHR5cGUgPyAnZWwtYnV0dG9uLS0nICsgdHlwZSA6ICcnLFxuICAgICAgYnV0dG9uU2l6ZSA/ICdlbC1idXR0b24tLScgKyBidXR0b25TaXplIDogJycsXG4gICAgICB7XG4gICAgICAgICdpcy1kaXNhYmxlZCc6IGJ1dHRvbkRpc2FibGVkLFxuICAgICAgICAnaXMtbG9hZGluZyc6IGxvYWRpbmcsXG4gICAgICAgICdpcy1wbGFpbic6IHBsYWluLFxuICAgICAgICAnaXMtcm91bmQnOiByb3VuZCxcbiAgICAgICAgJ2lzLWNpcmNsZSc6IGNpcmNsZVxuICAgICAgfVxuICAgIF1cIlxuICA+XG4gICAgPGkgY2xhc3M9XCJlbC1pY29uLWxvYWRpbmdcIiB2LWlmPVwibG9hZGluZ1wiPjwvaT5cbiAgICA8aSA6Y2xhc3M9XCJpY29uXCIgdi1pZj1cImljb24gJiYgIWxvYWRpbmdcIj48L2k+XG4gICAgPHNwYW4gdi1pZj1cIiRzbG90cy5kZWZhdWx0XCI+PHNsb3Q+PC9zbG90Pjwvc3Bhbj5cbiAgPC9idXR0b24+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdFbEJ1dHRvbicsXG5cbiAgICBpbmplY3Q6IHtcbiAgICAgIGVsRm9ybToge1xuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIGVsRm9ybUl0ZW06IHtcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICAgIH0sXG4gICAgICBzaXplOiBTdHJpbmcsXG4gICAgICBpY29uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0sXG4gICAgICBuYXRpdmVUeXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgIH0sXG4gICAgICBsb2FkaW5nOiBCb29sZWFuLFxuICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICBwbGFpbjogQm9vbGVhbixcbiAgICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICAgIHJvdW5kOiBCb29sZWFuLFxuICAgICAgY2lyY2xlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBfZWxGb3JtSXRlbVNpemUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5lbEZvcm1JdGVtIHx8IHt9KS5lbEZvcm1JdGVtU2l6ZTtcbiAgICAgIH0sXG4gICAgICBidXR0b25TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplIHx8IHRoaXMuX2VsRm9ybUl0ZW1TaXplIHx8ICh0aGlzLiRFTEVNRU5UIHx8IHt9KS5zaXplO1xuICAgICAgfSxcbiAgICAgIGJ1dHRvbkRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEuaGFzT3duUHJvcGVydHkoJ2Rpc2FibGVkJykgPyB0aGlzLmRpc2FibGVkIDogKHRoaXMuZWxGb3JtIHx8IHt9KS5kaXNhYmxlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFuZGxlQ2xpY2soZXZ0KSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vaW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWVkNzM0YjZhJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9ob21lL3BhbmEvd29ya3NwYWNlL2dvb2dsZS95eHR4L25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJ2VkNzM0YjZhJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJ2VkNzM0YjZhJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJ2VkNzM0YjZhJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9pbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZWQ3MzRiNmEmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignZWQ3MzRiNmEnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIm5vZGVfbW9kdWxlcy9lbGVtZW50LXVpL3BhY2thZ2VzL2lucHV0L3NyYy9pbnB1dC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCI8dGVtcGxhdGU+XG4gIDxkaXYgOmNsYXNzPVwiW1xuICAgIHR5cGUgPT09ICd0ZXh0YXJlYScgPyAnZWwtdGV4dGFyZWEnIDogJ2VsLWlucHV0JyxcbiAgICBpbnB1dFNpemUgPyAnZWwtaW5wdXQtLScgKyBpbnB1dFNpemUgOiAnJyxcbiAgICB7XG4gICAgICAnaXMtZGlzYWJsZWQnOiBpbnB1dERpc2FibGVkLFxuICAgICAgJ2lzLWV4Y2VlZCc6IGlucHV0RXhjZWVkLFxuICAgICAgJ2VsLWlucHV0LWdyb3VwJzogJHNsb3RzLnByZXBlbmQgfHwgJHNsb3RzLmFwcGVuZCxcbiAgICAgICdlbC1pbnB1dC1ncm91cC0tYXBwZW5kJzogJHNsb3RzLmFwcGVuZCxcbiAgICAgICdlbC1pbnB1dC1ncm91cC0tcHJlcGVuZCc6ICRzbG90cy5wcmVwZW5kLFxuICAgICAgJ2VsLWlucHV0LS1wcmVmaXgnOiAkc2xvdHMucHJlZml4IHx8IHByZWZpeEljb24sXG4gICAgICAnZWwtaW5wdXQtLXN1ZmZpeCc6ICRzbG90cy5zdWZmaXggfHwgc3VmZml4SWNvbiB8fCBjbGVhcmFibGUgfHwgc2hvd1Bhc3N3b3JkXG4gICAgfVxuICAgIF1cIlxuICAgIEBtb3VzZWVudGVyPVwiaG92ZXJpbmcgPSB0cnVlXCJcbiAgICBAbW91c2VsZWF2ZT1cImhvdmVyaW5nID0gZmFsc2VcIlxuICA+XG4gICAgPHRlbXBsYXRlIHYtaWY9XCJ0eXBlICE9PSAndGV4dGFyZWEnXCI+XG4gICAgICA8IS0tIOWJjee9ruWFg+e0oCAtLT5cbiAgICAgIDxkaXYgY2xhc3M9XCJlbC1pbnB1dC1ncm91cF9fcHJlcGVuZFwiIHYtaWY9XCIkc2xvdHMucHJlcGVuZFwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwicHJlcGVuZFwiPjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgICAgPGlucHV0XG4gICAgICAgIDp0YWJpbmRleD1cInRhYmluZGV4XCJcbiAgICAgICAgdi1pZj1cInR5cGUgIT09ICd0ZXh0YXJlYSdcIlxuICAgICAgICBjbGFzcz1cImVsLWlucHV0X19pbm5lclwiXG4gICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgIDp0eXBlPVwic2hvd1Bhc3N3b3JkID8gKHBhc3N3b3JkVmlzaWJsZSA/ICd0ZXh0JzogJ3Bhc3N3b3JkJykgOiB0eXBlXCJcbiAgICAgICAgOmRpc2FibGVkPVwiaW5wdXREaXNhYmxlZFwiXG4gICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgOmF1dG9jb21wbGV0ZT1cImF1dG9Db21wbGV0ZSB8fCBhdXRvY29tcGxldGVcIlxuICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgIEBjb21wb3NpdGlvbnN0YXJ0PVwiaGFuZGxlQ29tcG9zaXRpb25TdGFydFwiXG4gICAgICAgIEBjb21wb3NpdGlvbnVwZGF0ZT1cImhhbmRsZUNvbXBvc2l0aW9uVXBkYXRlXCJcbiAgICAgICAgQGNvbXBvc2l0aW9uZW5kPVwiaGFuZGxlQ29tcG9zaXRpb25FbmRcIlxuICAgICAgICBAaW5wdXQ9XCJoYW5kbGVJbnB1dFwiXG4gICAgICAgIEBmb2N1cz1cImhhbmRsZUZvY3VzXCJcbiAgICAgICAgQGJsdXI9XCJoYW5kbGVCbHVyXCJcbiAgICAgICAgQGNoYW5nZT1cImhhbmRsZUNoYW5nZVwiXG4gICAgICAgIDphcmlhLWxhYmVsPVwibGFiZWxcIlxuICAgICAgPlxuICAgICAgPCEtLSDliY3nva7lhoXlrrkgLS0+XG4gICAgICA8c3BhbiBjbGFzcz1cImVsLWlucHV0X19wcmVmaXhcIiB2LWlmPVwiJHNsb3RzLnByZWZpeCB8fCBwcmVmaXhJY29uXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJwcmVmaXhcIj48L3Nsb3Q+XG4gICAgICAgIDxpIGNsYXNzPVwiZWwtaW5wdXRfX2ljb25cIlxuICAgICAgICAgICB2LWlmPVwicHJlZml4SWNvblwiXG4gICAgICAgICAgIDpjbGFzcz1cInByZWZpeEljb25cIj5cbiAgICAgICAgPC9pPlxuICAgICAgPC9zcGFuPlxuICAgICAgPCEtLSDlkI7nva7lhoXlrrkgLS0+XG4gICAgICA8c3BhblxuICAgICAgICBjbGFzcz1cImVsLWlucHV0X19zdWZmaXhcIlxuICAgICAgICB2LWlmPVwiZ2V0U3VmZml4VmlzaWJsZSgpXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZWwtaW5wdXRfX3N1ZmZpeC1pbm5lclwiPlxuICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiIXNob3dDbGVhciB8fCAhc2hvd1B3ZFZpc2libGUgfHwgIWlzV29yZExpbWl0VmlzaWJsZVwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInN1ZmZpeFwiPjwvc2xvdD5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZWwtaW5wdXRfX2ljb25cIlxuICAgICAgICAgICAgICB2LWlmPVwic3VmZml4SWNvblwiXG4gICAgICAgICAgICAgIDpjbGFzcz1cInN1ZmZpeEljb25cIj5cbiAgICAgICAgICAgIDwvaT5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgIDxpIHYtaWY9XCJzaG93Q2xlYXJcIlxuICAgICAgICAgICAgY2xhc3M9XCJlbC1pbnB1dF9faWNvbiBlbC1pY29uLWNpcmNsZS1jbG9zZSBlbC1pbnB1dF9fY2xlYXJcIlxuICAgICAgICAgICAgQG1vdXNlZG93bi5wcmV2ZW50XG4gICAgICAgICAgICBAY2xpY2s9XCJjbGVhclwiXG4gICAgICAgICAgPjwvaT5cbiAgICAgICAgICA8aSB2LWlmPVwic2hvd1B3ZFZpc2libGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJlbC1pbnB1dF9faWNvbiBlbC1pY29uLXZpZXcgZWwtaW5wdXRfX2NsZWFyXCJcbiAgICAgICAgICAgIEBjbGljaz1cImhhbmRsZVBhc3N3b3JkVmlzaWJsZVwiXG4gICAgICAgICAgPjwvaT5cbiAgICAgICAgICA8c3BhbiB2LWlmPVwiaXNXb3JkTGltaXRWaXNpYmxlXCIgY2xhc3M9XCJlbC1pbnB1dF9fY291bnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZWwtaW5wdXRfX2NvdW50LWlubmVyXCI+XG4gICAgICAgICAgICAgIHt7IHRleHRMZW5ndGggfX0ve3sgdXBwZXJMaW1pdCB9fVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8aSBjbGFzcz1cImVsLWlucHV0X19pY29uXCJcbiAgICAgICAgICB2LWlmPVwidmFsaWRhdGVTdGF0ZVwiXG4gICAgICAgICAgOmNsYXNzPVwiWydlbC1pbnB1dF9fdmFsaWRhdGVJY29uJywgdmFsaWRhdGVJY29uXVwiPlxuICAgICAgICA8L2k+XG4gICAgICA8L3NwYW4+XG4gICAgICA8IS0tIOWQjue9ruWFg+e0oCAtLT5cbiAgICAgIDxkaXYgY2xhc3M9XCJlbC1pbnB1dC1ncm91cF9fYXBwZW5kXCIgdi1pZj1cIiRzbG90cy5hcHBlbmRcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImFwcGVuZFwiPjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIDwvdGVtcGxhdGU+XG4gICAgPHRleHRhcmVhXG4gICAgICB2LWVsc2VcbiAgICAgIDp0YWJpbmRleD1cInRhYmluZGV4XCJcbiAgICAgIGNsYXNzPVwiZWwtdGV4dGFyZWFfX2lubmVyXCJcbiAgICAgIEBjb21wb3NpdGlvbnN0YXJ0PVwiaGFuZGxlQ29tcG9zaXRpb25TdGFydFwiXG4gICAgICBAY29tcG9zaXRpb251cGRhdGU9XCJoYW5kbGVDb21wb3NpdGlvblVwZGF0ZVwiXG4gICAgICBAY29tcG9zaXRpb25lbmQ9XCJoYW5kbGVDb21wb3NpdGlvbkVuZFwiXG4gICAgICBAaW5wdXQ9XCJoYW5kbGVJbnB1dFwiXG4gICAgICByZWY9XCJ0ZXh0YXJlYVwiXG4gICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgOmRpc2FibGVkPVwiaW5wdXREaXNhYmxlZFwiXG4gICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICA6YXV0b2NvbXBsZXRlPVwiYXV0b0NvbXBsZXRlIHx8IGF1dG9jb21wbGV0ZVwiXG4gICAgICA6c3R5bGU9XCJ0ZXh0YXJlYVN0eWxlXCJcbiAgICAgIEBmb2N1cz1cImhhbmRsZUZvY3VzXCJcbiAgICAgIEBibHVyPVwiaGFuZGxlQmx1clwiXG4gICAgICBAY2hhbmdlPVwiaGFuZGxlQ2hhbmdlXCJcbiAgICAgIDphcmlhLWxhYmVsPVwibGFiZWxcIlxuICAgID5cbiAgICA8L3RleHRhcmVhPlxuICAgIDxzcGFuIHYtaWY9XCJpc1dvcmRMaW1pdFZpc2libGUgJiYgdHlwZSA9PT0gJ3RleHRhcmVhJ1wiIGNsYXNzPVwiZWwtaW5wdXRfX2NvdW50XCI+e3sgdGV4dExlbmd0aCB9fS97eyB1cHBlckxpbWl0IH19PC9zcGFuPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuICBpbXBvcnQgZW1pdHRlciBmcm9tICdlbGVtZW50LXVpL3NyYy9taXhpbnMvZW1pdHRlcic7XG4gIGltcG9ydCBNaWdyYXRpbmcgZnJvbSAnZWxlbWVudC11aS9zcmMvbWl4aW5zL21pZ3JhdGluZyc7XG4gIGltcG9ydCBjYWxjVGV4dGFyZWFIZWlnaHQgZnJvbSAnLi9jYWxjVGV4dGFyZWFIZWlnaHQnO1xuICBpbXBvcnQgbWVyZ2UgZnJvbSAnZWxlbWVudC11aS9zcmMvdXRpbHMvbWVyZ2UnO1xuICBpbXBvcnQge2lzS29yZWFufSBmcm9tICdlbGVtZW50LXVpL3NyYy91dGlscy9zaGFyZWQnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnRWxJbnB1dCcsXG5cbiAgICBjb21wb25lbnROYW1lOiAnRWxJbnB1dCcsXG5cbiAgICBtaXhpbnM6IFtlbWl0dGVyLCBNaWdyYXRpbmddLFxuXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcblxuICAgIGluamVjdDoge1xuICAgICAgZWxGb3JtOiB7XG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgZWxGb3JtSXRlbToge1xuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dGFyZWFDYWxjU3R5bGU6IHt9LFxuICAgICAgICBob3ZlcmluZzogZmFsc2UsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBpc0NvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIHBhc3N3b3JkVmlzaWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICB2YWx1ZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIHNpemU6IFN0cmluZyxcbiAgICAgIHJlc2l6ZTogU3RyaW5nLFxuICAgICAgZm9ybTogU3RyaW5nLFxuICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICByZWFkb25seTogQm9vbGVhbixcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICAgIH0sXG4gICAgICBhdXRvc2l6ZToge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhdXRvY29tcGxldGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnb2ZmJ1xuICAgICAgfSxcbiAgICAgIC8qKiBARGVwcmVjYXRlZCBpbiBuZXh0IG1ham9yIHZlcnNpb24gKi9cbiAgICAgIGF1dG9Db21wbGV0ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tFbGVtZW50IFdhcm5dW0lucHV0XVxcJ2F1dG8tY29tcGxldGVcXCcgcHJvcGVydHkgd2lsbCBiZSBkZXByZWNhdGVkIGluIG5leHQgbWFqb3IgdmVyc2lvbi4gcGxlYXNlIHVzZSBcXCdhdXRvY29tcGxldGVcXCcgaW5zdGVhZC4nKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHN1ZmZpeEljb246IFN0cmluZyxcbiAgICAgIHByZWZpeEljb246IFN0cmluZyxcbiAgICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgICBjbGVhcmFibGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzaG93UGFzc3dvcmQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzaG93V29yZExpbWl0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdGFiaW5kZXg6IFN0cmluZ1xuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgX2VsRm9ybUl0ZW1TaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZWxGb3JtSXRlbSB8fCB7fSkuZWxGb3JtSXRlbVNpemU7XG4gICAgICB9LFxuICAgICAgdmFsaWRhdGVTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxGb3JtSXRlbSA/IHRoaXMuZWxGb3JtSXRlbS52YWxpZGF0ZVN0YXRlIDogJyc7XG4gICAgICB9LFxuICAgICAgbmVlZFN0YXR1c0ljb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsRm9ybSA/IHRoaXMuZWxGb3JtLnN0YXR1c0ljb24gOiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZUljb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWRhdGluZzogJ2VsLWljb24tbG9hZGluZycsXG4gICAgICAgICAgc3VjY2VzczogJ2VsLWljb24tY2lyY2xlLWNoZWNrJyxcbiAgICAgICAgICBlcnJvcjogJ2VsLWljb24tY2lyY2xlLWNsb3NlJ1xuICAgICAgICB9W3RoaXMudmFsaWRhdGVTdGF0ZV07XG4gICAgICB9LFxuICAgICAgdGV4dGFyZWFTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCB0aGlzLnRleHRhcmVhQ2FsY1N0eWxlLCB7IHJlc2l6ZTogdGhpcy5yZXNpemUgfSk7XG4gICAgICB9LFxuICAgICAgaW5wdXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplIHx8IHRoaXMuX2VsRm9ybUl0ZW1TaXplIHx8ICh0aGlzLiRFTEVNRU5UIHx8IHt9KS5zaXplO1xuICAgICAgfSxcbiAgICAgIGlucHV0RGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8ICh0aGlzLmVsRm9ybSB8fCB7fSkuZGlzYWJsZWQ7XG4gICAgICB9LFxuICAgICAgbmF0aXZlSW5wdXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG51bGwgfHwgdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgc2hvd0NsZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcmFibGUgJiZcbiAgICAgICAgICAhdGhpcy5pbnB1dERpc2FibGVkICYmXG4gICAgICAgICAgIXRoaXMucmVhZG9ubHkgJiZcbiAgICAgICAgICB0aGlzLm5hdGl2ZUlucHV0VmFsdWUgJiZcbiAgICAgICAgICAodGhpcy5mb2N1c2VkIHx8IHRoaXMuaG92ZXJpbmcpO1xuICAgICAgfSxcbiAgICAgIHNob3dQd2RWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93UGFzc3dvcmQgJiZcbiAgICAgICAgICAhdGhpcy5pbnB1dERpc2FibGVkICYmXG4gICAgICAgICAgIXRoaXMucmVhZG9ubHkgJiZcbiAgICAgICAgICAoISF0aGlzLm5hdGl2ZUlucHV0VmFsdWUgfHwgdGhpcy5mb2N1c2VkKTtcbiAgICAgIH0sXG4gICAgICBpc1dvcmRMaW1pdFZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dXb3JkTGltaXQgJiZcbiAgICAgICAgICB0aGlzLiRhdHRycy5tYXhsZW5ndGggJiZcbiAgICAgICAgICAodGhpcy50eXBlID09PSAndGV4dCcgfHwgdGhpcy50eXBlID09PSAndGV4dGFyZWEnKSAmJlxuICAgICAgICAgICF0aGlzLmlucHV0RGlzYWJsZWQgJiZcbiAgICAgICAgICAhdGhpcy5yZWFkb25seSAmJlxuICAgICAgICAgICF0aGlzLnNob3dQYXNzd29yZDtcbiAgICAgIH0sXG4gICAgICB1cHBlckxpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXR0cnMubWF4bGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIHRleHRMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSB8fCAnJykubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGlucHV0RXhjZWVkKCkge1xuICAgICAgICAvLyBzaG93IGV4Y2VlZCBzdHlsZSBpZiBsZW5ndGggb2YgaW5pdGlhbCB2YWx1ZSBncmVhdGVyIHRoZW4gbWF4bGVuZ3RoXG4gICAgICAgIHJldHVybiB0aGlzLmlzV29yZExpbWl0VmlzaWJsZSAmJlxuICAgICAgICAgICh0aGlzLnRleHRMZW5ndGggPiB0aGlzLnVwcGVyTGltaXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgdmFsdWUodmFsKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMucmVzaXplVGV4dGFyZWEpO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZUV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCgnRWxGb3JtSXRlbScsICdlbC5mb3JtLmNoYW5nZScsIFt2YWxdKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIG5hdGl2ZSBpbnB1dCB2YWx1ZSBpcyBzZXQgZXhwbGljaXRseVxuICAgICAgLy8gZG8gbm90IHVzZSB2LW1vZGVsIC8gOnZhbHVlIGluIHRlbXBsYXRlXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9FbGVtZUZFL2VsZW1lbnQvaXNzdWVzLzE0NTIxXG4gICAgICBuYXRpdmVJbnB1dFZhbHVlKCkge1xuICAgICAgICB0aGlzLnNldE5hdGl2ZUlucHV0VmFsdWUoKTtcbiAgICAgIH0sXG4gICAgICAvLyB3aGVuIGNoYW5nZSBiZXR3ZWVuIDxpbnB1dD4gYW5kIDx0ZXh0YXJlYT4sXG4gICAgICAvLyB1cGRhdGUgRE9NIGRlcGVuZGVudCB2YWx1ZSBhbmQgc3R5bGVzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2lzc3Vlcy8xNDg1N1xuICAgICAgdHlwZSgpIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0TmF0aXZlSW5wdXRWYWx1ZSgpO1xuICAgICAgICAgIHRoaXMucmVzaXplVGV4dGFyZWEoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUljb25PZmZzZXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBibHVyKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuYmx1cigpO1xuICAgICAgfSxcbiAgICAgIGdldE1pZ3JhdGluZ0NvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgJ2ljb24nOiAnaWNvbiBpcyByZW1vdmVkLCB1c2Ugc3VmZml4LWljb24gLyBwcmVmaXgtaWNvbiBpbnN0ZWFkLicsXG4gICAgICAgICAgICAnb24taWNvbi1jbGljayc6ICdvbi1pY29uLWNsaWNrIGlzIHJlbW92ZWQuJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAnY2xpY2snOiAnY2xpY2sgaXMgcmVtb3ZlZC4nXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdFbEZvcm1JdGVtJywgJ2VsLmZvcm0uYmx1cicsIFt0aGlzLnZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS5zZWxlY3QoKTtcbiAgICAgIH0sXG4gICAgICByZXNpemVUZXh0YXJlYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzU2VydmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYXV0b3NpemUsIHR5cGUgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlICE9PSAndGV4dGFyZWEnKSByZXR1cm47XG4gICAgICAgIGlmICghYXV0b3NpemUpIHtcbiAgICAgICAgICB0aGlzLnRleHRhcmVhQ2FsY1N0eWxlID0ge1xuICAgICAgICAgICAgbWluSGVpZ2h0OiBjYWxjVGV4dGFyZWFIZWlnaHQodGhpcy4kcmVmcy50ZXh0YXJlYSkubWluSGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWluUm93cyA9IGF1dG9zaXplLm1pblJvd3M7XG4gICAgICAgIGNvbnN0IG1heFJvd3MgPSBhdXRvc2l6ZS5tYXhSb3dzO1xuXG4gICAgICAgIHRoaXMudGV4dGFyZWFDYWxjU3R5bGUgPSBjYWxjVGV4dGFyZWFIZWlnaHQodGhpcy4kcmVmcy50ZXh0YXJlYSwgbWluUm93cywgbWF4Um93cyk7XG4gICAgICB9LFxuICAgICAgc2V0TmF0aXZlSW5wdXRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybjtcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlID09PSB0aGlzLm5hdGl2ZUlucHV0VmFsdWUpIHJldHVybjtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLm5hdGl2ZUlucHV0VmFsdWU7XG4gICAgICB9LFxuICAgICAgaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZW1pdCgnZm9jdXMnLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ29tcG9zaXRpb25TdGFydChldmVudCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjb21wb3NpdGlvbnN0YXJ0JywgZXZlbnQpO1xuICAgICAgICB0aGlzLmlzQ29tcG9zaW5nID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDb21wb3NpdGlvblVwZGF0ZShldmVudCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjb21wb3NpdGlvbnVwZGF0ZScsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGFzdENoYXJhY3RlciA9IHRleHRbdGV4dC5sZW5ndGggLSAxXSB8fCAnJztcbiAgICAgICAgdGhpcy5pc0NvbXBvc2luZyA9ICFpc0tvcmVhbihsYXN0Q2hhcmFjdGVyKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDb21wb3NpdGlvbkVuZChldmVudCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjb21wb3NpdGlvbmVuZCcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICB0aGlzLmlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbnB1dChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVJbnB1dChldmVudCkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGVtaXQgaW5wdXQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC9pc3N1ZXMvMTA1MTZcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wb3NpbmcpIHJldHVybjtcblxuICAgICAgICAvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2lzc3Vlcy84NTQ4XG4gICAgICAgIC8vIHNob3VsZCByZW1vdmUgdGhlIGZvbGxvd2luZyBsaW5lIHdoZW4gd2UgZG9uJ3Qgc3VwcG9ydCBJRVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlID09PSB0aGlzLm5hdGl2ZUlucHV0VmFsdWUpIHJldHVybjtcblxuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIG5hdGl2ZSBpbnB1dCB2YWx1ZSBpcyBjb250cm9sbGVkXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC9pc3N1ZXMvMTI4NTBcbiAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5zZXROYXRpdmVJbnB1dFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBjYWxjSWNvbk9mZnNldChwbGFjZSkge1xuICAgICAgICBsZXQgZWxMaXN0ID0gW10uc2xpY2UuY2FsbCh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGAuZWwtaW5wdXRfXyR7cGxhY2V9YCkgfHwgW10pO1xuICAgICAgICBpZiAoIWVsTGlzdC5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgbGV0IGVsID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZWxMaXN0W2ldLnBhcmVudE5vZGUgPT09IHRoaXMuJGVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsTGlzdFtpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHBlbmRhbnRNYXAgPSB7XG4gICAgICAgICAgc3VmZml4OiAnYXBwZW5kJyxcbiAgICAgICAgICBwcmVmaXg6ICdwcmVwZW5kJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHBlbmRhbnQgPSBwZW5kYW50TWFwW3BsYWNlXTtcbiAgICAgICAgaWYgKHRoaXMuJHNsb3RzW3BlbmRhbnRdKSB7XG4gICAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtwbGFjZSA9PT0gJ3N1ZmZpeCcgPyAnLScgOiAnJ30ke3RoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoYC5lbC1pbnB1dC1ncm91cF9fJHtwZW5kYW50fWApLm9mZnNldFdpZHRofXB4KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlSWNvbk9mZnNldCgpIHtcbiAgICAgICAgdGhpcy5jYWxjSWNvbk9mZnNldCgncHJlZml4Jyk7XG4gICAgICAgIHRoaXMuY2FsY0ljb25PZmZzZXQoJ3N1ZmZpeCcpO1xuICAgICAgfSxcbiAgICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsICcnKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgJycpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjbGVhcicpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVBhc3N3b3JkVmlzaWJsZSgpIHtcbiAgICAgICAgdGhpcy5wYXNzd29yZFZpc2libGUgPSAhdGhpcy5wYXNzd29yZFZpc2libGU7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldElucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dCB8fCB0aGlzLiRyZWZzLnRleHRhcmVhO1xuICAgICAgfSxcbiAgICAgIGdldFN1ZmZpeFZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzbG90cy5zdWZmaXggfHxcbiAgICAgICAgICB0aGlzLnN1ZmZpeEljb24gfHxcbiAgICAgICAgICB0aGlzLnNob3dDbGVhciB8fFxuICAgICAgICAgIHRoaXMuc2hvd1Bhc3N3b3JkIHx8XG4gICAgICAgICAgdGhpcy5pc1dvcmRMaW1pdFZpc2libGUgfHxcbiAgICAgICAgICAodGhpcy52YWxpZGF0ZVN0YXRlICYmIHRoaXMubmVlZFN0YXR1c0ljb24pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVkKCkge1xuICAgICAgdGhpcy4kb24oJ2lucHV0U2VsZWN0JywgdGhpcy5zZWxlY3QpO1xuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5zZXROYXRpdmVJbnB1dFZhbHVlKCk7XG4gICAgICB0aGlzLnJlc2l6ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLnVwZGF0ZUljb25PZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlZCgpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlSWNvbk9mZnNldCk7XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9idXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9idXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uLy4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9idXR0b24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBjMmRlZTJhJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vLi4vdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2lucHV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lZDczNGI2YSZcIiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiYnV0dG9uXCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtYnV0dG9uXCIsXG4gICAgICBjbGFzczogW1xuICAgICAgICBfdm0udHlwZSA/IFwiZWwtYnV0dG9uLS1cIiArIF92bS50eXBlIDogXCJcIixcbiAgICAgICAgX3ZtLmJ1dHRvblNpemUgPyBcImVsLWJ1dHRvbi0tXCIgKyBfdm0uYnV0dG9uU2l6ZSA6IFwiXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcImlzLWRpc2FibGVkXCI6IF92bS5idXR0b25EaXNhYmxlZCxcbiAgICAgICAgICBcImlzLWxvYWRpbmdcIjogX3ZtLmxvYWRpbmcsXG4gICAgICAgICAgXCJpcy1wbGFpblwiOiBfdm0ucGxhaW4sXG4gICAgICAgICAgXCJpcy1yb3VuZFwiOiBfdm0ucm91bmQsXG4gICAgICAgICAgXCJpcy1jaXJjbGVcIjogX3ZtLmNpcmNsZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBhdHRyczoge1xuICAgICAgICBkaXNhYmxlZDogX3ZtLmJ1dHRvbkRpc2FibGVkIHx8IF92bS5sb2FkaW5nLFxuICAgICAgICBhdXRvZm9jdXM6IF92bS5hdXRvZm9jdXMsXG4gICAgICAgIHR5cGU6IF92bS5uYXRpdmVUeXBlLFxuICAgICAgfSxcbiAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlQ2xpY2sgfSxcbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS5sb2FkaW5nID8gX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtaWNvbi1sb2FkaW5nXCIgfSkgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5pY29uICYmICFfdm0ubG9hZGluZyA/IF9jKFwiaVwiLCB7IGNsYXNzOiBfdm0uaWNvbiB9KSA6IF92bS5fZSgpLFxuICAgICAgX3ZtLiRzbG90cy5kZWZhdWx0ID8gX2MoXCJzcGFuXCIsIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMikgOiBfdm0uX2UoKSxcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzOiBbXG4gICAgICAgIF92bS50eXBlID09PSBcInRleHRhcmVhXCIgPyBcImVsLXRleHRhcmVhXCIgOiBcImVsLWlucHV0XCIsXG4gICAgICAgIF92bS5pbnB1dFNpemUgPyBcImVsLWlucHV0LS1cIiArIF92bS5pbnB1dFNpemUgOiBcIlwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpcy1kaXNhYmxlZFwiOiBfdm0uaW5wdXREaXNhYmxlZCxcbiAgICAgICAgICBcImlzLWV4Y2VlZFwiOiBfdm0uaW5wdXRFeGNlZWQsXG4gICAgICAgICAgXCJlbC1pbnB1dC1ncm91cFwiOiBfdm0uJHNsb3RzLnByZXBlbmQgfHwgX3ZtLiRzbG90cy5hcHBlbmQsXG4gICAgICAgICAgXCJlbC1pbnB1dC1ncm91cC0tYXBwZW5kXCI6IF92bS4kc2xvdHMuYXBwZW5kLFxuICAgICAgICAgIFwiZWwtaW5wdXQtZ3JvdXAtLXByZXBlbmRcIjogX3ZtLiRzbG90cy5wcmVwZW5kLFxuICAgICAgICAgIFwiZWwtaW5wdXQtLXByZWZpeFwiOiBfdm0uJHNsb3RzLnByZWZpeCB8fCBfdm0ucHJlZml4SWNvbixcbiAgICAgICAgICBcImVsLWlucHV0LS1zdWZmaXhcIjpcbiAgICAgICAgICAgIF92bS4kc2xvdHMuc3VmZml4IHx8XG4gICAgICAgICAgICBfdm0uc3VmZml4SWNvbiB8fFxuICAgICAgICAgICAgX3ZtLmNsZWFyYWJsZSB8fFxuICAgICAgICAgICAgX3ZtLnNob3dQYXNzd29yZCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBvbjoge1xuICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmhvdmVyaW5nID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmhvdmVyaW5nID0gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBbXG4gICAgICBfdm0udHlwZSAhPT0gXCJ0ZXh0YXJlYVwiXG4gICAgICAgID8gW1xuICAgICAgICAgICAgX3ZtLiRzbG90cy5wcmVwZW5kXG4gICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1pbnB1dC1ncm91cF9fcHJlcGVuZFwiIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl90KFwicHJlcGVuZFwiKV0sXG4gICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLnR5cGUgIT09IFwidGV4dGFyZWFcIlxuICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2lubmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4OiBfdm0udGFiaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfdm0uc2hvd1Bhc3N3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gX3ZtLnBhc3N3b3JkVmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IF92bS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5pbnB1dERpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IF92bS5yZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogX3ZtLmF1dG9Db21wbGV0ZSB8fCBfdm0uYXV0b2NvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IF92bS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbnN0YXJ0OiBfdm0uaGFuZGxlQ29tcG9zaXRpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9udXBkYXRlOiBfdm0uaGFuZGxlQ29tcG9zaXRpb25VcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbmVuZDogX3ZtLmhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IF92bS5oYW5kbGVJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBfdm0uaGFuZGxlRm9jdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBibHVyOiBfdm0uaGFuZGxlQmx1cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogX3ZtLmhhbmRsZUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgIF92bS4kYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLiRzbG90cy5wcmVmaXggfHwgX3ZtLnByZWZpeEljb25cbiAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1pbnB1dF9fcHJlZml4XCIgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl90KFwicHJlZml4XCIpLFxuICAgICAgICAgICAgICAgICAgICBfdm0ucHJlZml4SWNvblxuICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2ljb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF92bS5wcmVmaXhJY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICBfdm0uZ2V0U3VmZml4VmlzaWJsZSgpXG4gICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX3N1ZmZpeFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1pbnB1dF9fc3VmZml4LWlubmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICFfdm0uc2hvd0NsZWFyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIV92bS5zaG93UHdkVmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICFfdm0uaXNXb3JkTGltaXRWaXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3QoXCJzdWZmaXhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnN1ZmZpeEljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1pbnB1dF9faWNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfdm0uc3VmZml4SWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnNob3dDbGVhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1pbnB1dF9faWNvbiBlbC1pY29uLWNpcmNsZS1jbG9zZSBlbC1pbnB1dF9fY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IF92bS5jbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uc2hvd1B3ZFZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtaW5wdXRfX2ljb24gZWwtaWNvbi12aWV3IGVsLWlucHV0X19jbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlUGFzc3dvcmRWaXNpYmxlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5pc1dvcmRMaW1pdFZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2NvdW50XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLWlucHV0X19jb3VudC1pbm5lclwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udGV4dExlbmd0aCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS51cHBlckxpbWl0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgX3ZtLnZhbGlkYXRlU3RhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2ljb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBbXCJlbC1pbnB1dF9fdmFsaWRhdGVJY29uXCIsIF92bS52YWxpZGF0ZUljb25dLFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgIF92bS4kc2xvdHMuYXBwZW5kXG4gICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1pbnB1dC1ncm91cF9fYXBwZW5kXCIgfSxcbiAgICAgICAgICAgICAgICAgIFtfdm0uX3QoXCJhcHBlbmRcIildLFxuICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBdXG4gICAgICAgIDogX2MoXG4gICAgICAgICAgICBcInRleHRhcmVhXCIsXG4gICAgICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWY6IFwidGV4dGFyZWFcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10ZXh0YXJlYV9faW5uZXJcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogX3ZtLnRleHRhcmVhU3R5bGUsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIHRhYmluZGV4OiBfdm0udGFiaW5kZXgsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3ZtLmlucHV0RGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICByZWFkb25seTogX3ZtLnJlYWRvbmx5LFxuICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBfdm0uYXV0b0NvbXBsZXRlIHx8IF92bS5hdXRvY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogX3ZtLmxhYmVsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uc3RhcnQ6IF92bS5oYW5kbGVDb21wb3NpdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb251cGRhdGU6IF92bS5oYW5kbGVDb21wb3NpdGlvblVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uZW5kOiBfdm0uaGFuZGxlQ29tcG9zaXRpb25FbmQsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogX3ZtLmhhbmRsZUlucHV0LFxuICAgICAgICAgICAgICAgICAgZm9jdXM6IF92bS5oYW5kbGVGb2N1cyxcbiAgICAgICAgICAgICAgICAgIGJsdXI6IF92bS5oYW5kbGVCbHVyLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlOiBfdm0uaGFuZGxlQ2hhbmdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgICAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgX3ZtLmlzV29yZExpbWl0VmlzaWJsZSAmJiBfdm0udHlwZSA9PT0gXCJ0ZXh0YXJlYVwiXG4gICAgICAgID8gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2NvdW50XCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0udGV4dExlbmd0aCkgKyBcIi9cIiArIF92bS5fcyhfdm0udXBwZXJMaW1pdCkpLFxuICAgICAgICAgIF0pXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=